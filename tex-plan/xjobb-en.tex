\documentclass[a4paper,11pt]{kth-mag}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{lmodern}
\usepackage[latin1]{inputenc}
\usepackage[swedish,english]{babel}
\usepackage{modifications}
\usepackage{graphicx} % Required to insert images
\usepackage[colorlinks=true, citecolor=magenta, linkcolor=magenta]{hyperref}
\usepackage[nameinlink, capitalise]{cleveref}
\newcommand{\RN}[1]{%
      \textup{\uppercase\expandafter{\romannumeral#1}}%
  }
\usepackage{longtable}
\newcommand\fnurl[2]{%
    \href{#1}{#2}\footnote{\url{#1}}%
}
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}


\usepackage{amsmath}  % for \hookrightarrow
\usepackage{adjustbox}
\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\usepackage{xcolor}
\newcommand\myworries[1]{\textcolor{red}{#1}}

% F\"{o}r formateringen av en rapport/artikel finns ofta f\"{a}rdiga mallar. Publicerar man t.ex. en artikel p\r{a} en konferens eller i en tidskrift finns mallar/anvisningar som beskriver vilka typsnitt, storlekar, radavst\r{a}nd, marginaler paragrafnumrering etc. som skall anv\"{a}ndas.
% Ofta beskrivs ocks\r{a} hur l\r{a}ng texten f\r{a}r vara i antal ord och antal sidor.
% F\"{o}r den h\"{a}r uppgiften skall texten ligga mellan 7 och 12 sidor or\"{a}knat f\"{o}rs\"{a}ttsblad, Abstract, sammanfattning, referenslista och bilagor.

% Den h\"{a}r rapportmallen beskriver vad man kan f\"{o}rv\"{a}nta sig finna i en teknisk rapport som baseras p\r{a} n\r{a}gon form av unders\"{o}kning/utredning. De rubriker/stycken som \"{a}r beskrivna \"{a}r de som \r{a}terfinns i de allra flesta rapporter. F\"{o}r l\"{a}ngre rapporter delar man ofta upp rapporten i flera stycken med egna rubriker. T.ex. kanske man beskriver flera olika experiment och experimentuppst\"{a}llningar.

% I rapporten kan och b\"{o}r du \r{a}teranv\"{a}nda delar av det du skrivit i din projektplanering.

% F\"{o}rs\"{a}ttssida: Titeln skall vara deskriptiv/informativ. S\"{a}tts i Arial 14 punkter fet stil (KTH titel)

% F\"{o}rs\"{a}ttssida: H\"{a}r anger man namn p\r{a} alla f\"{o}rfattare, titlar och kontaktinformation
\title{Experimental Method - Planning}
\subtitle{\today}
\author{Wong, Sai Man\\ Tigerstr\"{o}m, Gabriel}
\blurb{}
\trita{}
\newcommand*{\skippara}{\par\vspace{\baselineskip} \noindent}
\begin{document}
\frontmatter
\pagestyle{empty}
\removepagenumbers
\maketitle
\selectlanguage{english}

% Ny sida- startar p\r{a} h\"{o}gersida: I examensarbetsrapporter p\r{a} KTH skall det finnas sammanfattning p\r{a} b\r{a}de svenska och engelska (Abstract). Rubriken s\"{a}tts i Arial 12 punkter fet stil ( KTH rubrik), br\"{o}dtexten som  Times New Roman 10 punkter (KTH Br\"{o}dtext)

% Ny sida, startar p\r{a} h\"{o}gersida. Sammanfattning och Abstract skall inneh\r{a}lla samma text men p\r{a} olika spr\r{a}k. Sammanfattningen skall \"{o}versiktligt beskriva vad rapporten inneh\r{a}ller och de viktigaste resultaten. Den h\r{a}lls normalt ganska kortfattad (1/4-1/2 A4 sida text. De skrivs p\r{a} separata sidor.

% Om man har ett bra verktyg som man skriver sin rapport i och man anv\"{a}nder v\"{a}ldefinierade paragraf/stilmallar s\r{a} kan inneh\r{a}llsf\"{o}rteckningen oftast automatgenereras
{
      \hypersetup{linkcolor=black}
      \tableofcontents*
}
\mainmatter
\pagestyle{newchap}


%----------------------------------------------------------------------------------------------------
%----------------------------------------------------------------------------------------------------
%--------------------------------------------NEW-----------------------------------------------------
%----------------------------------------------------------------------------------------------------
%----------------------------------------------------------------------------------------------------

\chapter{Experiment Method -- Planning}
\section{Introduction}\label{sec:intro}
A researcher plans in advance to conduct a successful and credible scientific work.
However, students and engineers occasionally carelessly approach the planning phase.
As a result, researchers waste time to redo the changes due to poor design and execution.
Students and engineers lack a more profound knowledge of the scientific method to produce high-quality work.
That is, science emphasizes the importance of theoretical knowledge and its application in practice.
Thus, in our study, we apply the scientific method to evaluate algorithms with a rigorous, honest and transparent method.

% Underrubriker (f\"{o}rsta niv\r{a}n) s\"{a}tts i Arial 12 punkter fet stil autonumrerad (KTH  nRubrik 2). (Har man ytterligare underniv\r{a}er s\"{a}tter man rubrikerna f\"{o}r n\"{a}sta niv\r{a}  med (KTH nRubrik 3)) Man f\"{o}rs\"{o}ker ofta beg\"{a}r\"{a}nsa sig till tre niv\r{a}er p\r{a} rubriker och man har i princip aldrig fler \"{a}n 4 niv\r{a}er p\r{a} rubriker.
%I stycket om bakgrund (som ibland kallas ”Related work” p\r{a} engelska) f\"{o}rv\"{a}ntar man sig hitta en gedigen bakgrundsbeskrivning till problemomr\r{a}det i stort och till det specifika problem som studeras i rapporten. Den skall inneh\r{a}lla/baseras p\r{a} en litteraturstudie. Det beh\"{o}ver v\"{a}l knappast p\r{a}pekas att den b\"{o}r inneh\r{a}lla utvalda, h\"{o}gkvalitativa referenser.
\subsection{Background}\label{sec:background}
A data structure represents a model to store data methodically \cite{deshpande2004c}.
Software engineers use queues in software development to manage arbitrary entities in a first-in-first-out (FIFO) order.
For example, developers use a queue to develop a memory buffer or scheduling in an operating system.

\skippara Higher level programming languages often provide a standardized library with complete implementations, such as a queue.
Software developers use these implementations frequently, and sometimes take the underlying architecture for granted.
Thus, an inexperienced developer possesses a limited knowledge of the theory and technical aspects of the used implementations.

\skippara Developers use the data structure, or model, linked list to store data linearly.
The simple linked list consists of entities.
An entity stores data and includes a connection to the next entity in the list.
Computer scientists and developers refer the entity as a node or an element, and the connection as a pointer.
Developers frequently use linked list implementations to store and manage data linearly, for example, in a queue implementation.


% H\"{a}r beskriver du problemomr\r{a}det och problemet i detalj. Beskriv ocks\r{a} varf\"{o}r det \"{a}r v\"{a}rdefullt att unders\"{o}ka problemet. F\"{o}rs\"{o}k formulera din problemst\"{a}llning s\r{a} klart och koncist som m\"{o}jligt – g\"{a}rna i en mening!
\subsection{Problem}\label{sec:problem}
Our task was to evaluate four variations of a list-based data structure to represent a queue \cite{Uppgiftl9:online}.
Each element comprises a number to represent its priority in the queue.
For clarification, an element with a low number represents higher priority, because the element lies closer to the present time and therefore ready for execution.
We must implement the queues in the low-level programming language \texttt{C}, and the following list presents the implementation specifications:
\begin{enumerate}
    \item \textbf{Singly linked list} -- Insertion of new elements takes place in the head.
    \item \textbf{Doubly linked list} -- Insertion of new elements takes place in the rear.
    \item \textbf{Doubly linked list} -- Insertion of new elements takes place based on the mean of the first and last element's priority.
        \begin{itemize}
            \item In the head -- The new element's priority is higher than the mean, that is, \\numerical value $<$ mean value.
            \item In the rear -- The new element's priority is lower than the mean, that is,\\numerical value $\ge$ mean value.
        \end{itemize}
    \item \textbf{Scheduling queue} -- The queue consists of an FIFO-queue for each priority in the $[0,40]$ interval.
\end{enumerate}

\skippara
Computer scientists evaluate algorithms by their execution time and memory usage.
We plan to gather a large quantity of these metrics to determine best, average and worst cases.
Thus, we ask ourselves: ``Do these queues achieve similar performance, or does the performance vary depending on the circumstance?''


\clearpage
% Om detta \"{a}r en studie d\"{a}r syftet \"{a}r att unders\"{o}ka en hypotes (alla projekt \"{a}r inte hypotespr\"{o}vande) s\r{a} beskriver du/formulerar du hypotesen h\"{a}r. L\"{a}mpligt \"{a}r ocks\r{a} att beskriva hur/varf\"{o}r/p\r{a} vilka grunder du formulerat hypotesen. Är det inte ett hypotespr\"{o}vande projekt s\r{a} tar du bort rubriken.
\subsection{Hypothesis}
A queue either enqueues or dequeues elements with a FIFO policy.
Because of the FIFO policy, based on a correct implementation and theory, the dequeue-operation takes $\mathcal{O}(1)$ time.
However, the enqueue-operation needs to consider an element's priority, because the algorithm inserts each element in the correct spot in the queue.
Thus, the implementations perform differently because of priority distribution.
For example, the implementation reaches $\mathcal{O}(n)$ time if the algorithm traverses through the entire list to enqueue an element.

\skippara The following list describes our hypotheses:
\begin{itemize}
    \item The dequeue-operation for all the queues takes $\mathcal{O}(1)$ time.
    \item The enqueue-operation for all the queues takes $\mathcal{O}(n)$ time.
\end{itemize}

% Beskriv varf\"{o}r projektet genomf\"{o}rs.
\subsection{Purpose}\label{sec:purpose}
Our purpose is to raise awareness of the features in standardized libraries, which developers and engineers often take for granted.
Thus, we applied the scientific method to conduct experiments and evaluate four versions of a priority queue implementation.
Consequently, we want to produce a credible and scientific work, so that other students and engineers can learn from, reproduce, and further develop.

% Beskriv de f\"{o}rv\"{a}ntade resultat- och effektm\r{a}len av unders\"{o}kningen. Beskriv alla m\r{a}l du satt upp \"{a}ven om de inte n\r{a}ddes!
\subsection{Goal}\label{sec:goal}
The goal is to attain deeper knowledge of the scientific method, and apply the method to evaluate four queue-implementations.
The following list demonstrates the sub-goals:
\begin{itemize}
    \item Apply the scientific method to plan, design, experiment, document, analyze and present the findings.
    \item Grasp the importance of scientific method.
    \item Conduct a reproducible study.
    \item Attain the ability to present, analyze and draw conclusions from experiments, both in theory and practice.
    \item Implement queues correctly, that is, verify its behavior and validate the data.
    \item Create tests to generate the execution time and memory usage from the algorithms.
\end{itemize}

% Beskriv vem och p\r{a} vilket s\"{a}tt man kan ha nytta av utredningen. Beskriv etiska och h\r{a}llbar utvecklingsrelaterade fr\r{a}gor kopplade till utredningen.
\subsection{Social Benefit, Ethics and Sustainable Development}
Our study might influence students and engineers to apply the scientific method with a more serious approach.
Also, the study facilitates the process for software engineers to choose an implementation of a queue, which fits their specific purpose.
Finally, we delve into the foundations of algorithms, data structure, and complexity theory.
Thus, our work helps students and engineers to acquire a deeper comprehension of computer science.

\skippara Within science, a researcher undertakes a moral responsibility to conduct a reproducible work with honesty and transparency.
However, sometimes scientists encounter difficult circumstances, which limits their ability to produce a reproducible work.
For example, due to economic and practical reasons, such as expensive hardware.
We will document each step and present our findings with rigor, honesty, and transparency.
That is, we encourage students to reproduce our findings.

\skippara We will experiment in a virtual machine on Microsoft's cloud platform.
Thus, we use the exact quantity of resources needed to conduct the experiments.
Thereby, avoiding waste of electricity due to, for example, system idle.



\clearpage
% ///////////////////////////////////
% ///////////////////////////////////
%       Method
% ///////////////////////////////////
% ///////////////////////////////////

% I metoelen beskriver du den vetenskapliga metod du baserat ditt projekt p\r{a}.
%
% Vilka relevanta metoder finns? Vilka har du \"{o}verv\"{a}gt att anv\"{a}nda? Varf\"{o}r valde du den/de metoder du anv\"{a}nt?
%  Beskriv kort den metod du anv\"{a}nt och hur du applicerat den - dvs. vilken data du samlar in, hur du g\"{o}r det och varf\"{o}r. Beskriv ocks\r{a} tillf\"{o}rlitligheten hos data du samlar in. G\r{a}r experimenten att upprepa? Finns etiska eller HU aspekter p\r{a} ditt arbete.
\section{Method}\label{sec:methods}

\subsection{Inductive and Deductive Method}
Scientists apply an inductive method to reach practical conclusions from observations or data \cite{Omexperi69:online}.
That is, in sequential order to 1) collect data, 2) detect the pattern in the data, 3) set up a hypothesis and 4) explain the findings with the established theory to reach 5) a conclusion \cite{web:induction}.
The method is sometimes informally called a bottom-up approach due to its style to first observe data.
Software engineers frequently apply an inductive method to observe algorithms and a system's behavior.
For example, a developer put in a specific input in the implementation and generate an output to observe the algorithm's performance.

\skippara With the deductive method, also called top-down approach, scientists reach logical conclusions from a theory first.
For example, mathematicians use a deductive method to explain the unknown with the help of established theory (axioms and theorems).
A deductive method also applies to researchers within computer science.
That is, computer scientists use mathematical notations to represent theoretical models in, for example, algorithm analysis and complexity theory.
Thus, researchers use these methods for a variety of purposes and sometimes combine them to reach both a logical and practical conclusion.

\subsection{Quantitative and Qualitative Method}
Researchers apply a quantitative method in studies, which rely on measurable data in large quantities to explain findings \cite{haakansson2013portal}.
That is, a quantitative study uses measurable metrics, such as time, temperature and age.
These studies apply statistical analysis to summarize the data in tables and graphs with error margins.
For example, scientists use a quantitative method to predict a nation's growth based on the birth and death rate over a more extended period.

\skippara In contrast, a qualitative method relies on data of quality to interpret the results \cite{merriam2009qualitative}.
Scientists use a qualitative method in studies when the data is significantly more difficult to quantify, such as opinions, thoughts, and happiness.
The researchers conduct, for example, interviews and surveys, to collect data from individuals.
Thus, psychologists often implement a qualitative method to examine people's behavior.

% Beskriv hur du samlar in data, material och annat underlag f\"{o}r din unders\"{o}kning? Svara p\r{a} fr\r{a}gor som: Hur skall unders\"{o}kningen genomf\"{o}ras? Hur \"{a}r experimentuppst\"{a}llningen organiserad?
\subsection{Data Collection}
We will be handling quantifiable metrics in our study.
That is, execution time and memory usage because computer scientists commonly apply these for algorithm complexity analysis.
In contrast to, for example, interviews and surveys, which the researchers within social sciences regularly use in qualitative studies \cite{Omexperi69:online, haakansson2013portal}.
That is, qualitative studies reach conclusions from the quality of the data.
Thus, our study use an experimental quantitative method to reach a broader insight into data structures and queue implementations.

\skippara For each of the four queue-implementations, we will test and generate the execution time for the best, average and worst case.
We will create input for the queues with varying distributions of the element's priorities.
Besides execution time, we will log the memory usage for each implementation.
Finally, we will write scripts to execute the tests and log the raw data.

% Beskriv metoden f\"{o}r hur du avser analysera insamlad data/material. Beskriv ocks\r{a} hur du planerar tolka  data
\subsection{Data Analysis}
We reason with a deductive method to explore the theory within computer science, such as algorithm complexity theory.
That is, we analyze the algorithms with the help of established complexity theory.
For example, to determine an algorithm's performance based solely on theoretical knowledge.
However, the usage of only a deductive method can yield unexpected results when put into practice.
Thus, we will generate realistic data from our experiments and use an inductive method to analyze the algorithms further.
That is, to explore if we can notice observable patterns in the data with the help of complexity models.

\skippara By running the experiments multiple times we can obtain the sample mean and standard deviation.
The standard deviation adds a deeper insight into the data and spread around the mean.
Also, it helps us to identify the external or internal error sources.
If the standard deviation is relatively high, then we can suspect that something is wrong with, for example, the underlying system.


\clearpage
% ///////////////////////////////////
% ///////////////////////////////////
%       System Description
% ///////////////////////////////////
% ///////////////////////////////////

% Ett kapitel om Systembeskrivning / Konstruktion eller i detta fall Experimentuppst\"{a}llning  finns inte med i alla studier men ofta i tekniska rapporter d\"{a}r man konstruerat ett system. Den h\"{a}r delen kan vara ett kapitel/stycke eller flera beroende p\r{a} hur stort arbete man gjort.

% H\"{a}r startar man normalt med en beskrivning av det/de system man utvecklat och /eller haft som underlag i studien.
\section{System Description}\label{section:system}


% Om du utvecklat ett system (som algoritmerna f\"{o}r den h\"{a}r studien) s\r{a} b\"{o}r du beskriva vilken/vilka metoder och verktyg du anv\"{a}nt f\"{o}r systemutvecklingen. I st\"{o}rre unders\"{o}kningar/arbeten vill man g\"{a}rna ocks\r{a} se en diskussion om olika alternativ och varf\"{o}r man valt de man anv\"{a}nt.
\subsection{System Development Method}
In our implementation, we plan to generate an executable for each of the four queue-implementations.
The experiment would consists of, for example, \texttt{main.c} containing the tests, \texttt{queues.h} and \texttt{queues.c} which respectively would describe and implement the functionalities of the queue.
Thus, we must use compile-time macros to determine the executable to produce based on the implementations, and check for memory leaks with, for example, Valgrind.

\skippara We plan to 1) use scripts and container technology (Docker) to automate the experiments.
Also, 2) to process and analyze the data, we can use mathematical tools, such as MATLAB or the Python library NumPy for scientific computing.
Lastly, we must 3) present these findings, analysis, and interpretation in form of tables and graphs in \LaTeX.\.
Thus, our procedure is to implement 1) to gather, 2) analyze and 3) present the data.
Docker containers introduce a practical approach to package software because containers use the same resources as the host operating system.

% Det h\"{a}r \"{a}r en anpassad rubrik f\"{o}r just den h\"{a}r studien. H\"{a}r beskriver du (ev. med flera underrubriker) mer i detalj de algoritmer du implementerat, analyserar dem och hur du implementerat dem.
\subsection{Queue Algorithms}\label{sec:algorithms}
Our task is to implement four different queue-implementation in the programming language \texttt{C}, as described in \cref{sec:problem}.
The following are standard operations for a queue:
\begin{itemize}
    \item \textbf{Enqueue} -- enqueues the element in the correct spot in the priority queue.
    \item \textbf{Dequeue} -- dequeues the element with the highest priority, that is, the first element in the queue.
\end{itemize}

\skippara The queues approach to enqueue varies for the implementations, because the algorithm traverses and inserts the new element in the correct position in the queue.
Each element stores at least 1) a unique number identifier of the data type integer, 2) a priority number of the data type double and 3) a pointer to refer to additional elements.

%%% Vad tycker du?
\skippara The following sections describe the implementation of the queues.
Additionally, we must analyze the time complexity for the enqueue-operation.
The theoretical average case's time complexity is more challenging to analyze compared to the best and worst case.
Thus, we can examine the best and worst cases in theory to interpret the average case for each implementation's enqueue-operation.

\subsubsection{Singly Linked List}\label{sec:singly}
This queue implementation uses a singly linked list to represent a queue.
That is, an element in the queue stores 1) a unique number identifier, 2) a priority and 3) a pointer to the next element in the queue.
The algorithm enqueues new elements from the head.
The following list analyzes the enqueue-operation's time complexity:
\begin{itemize}
    \item \textbf{Best Case $\mathcal{O}(1)$} --
        The best case occurs when the enqueue-operation of new elements always takes place in the head.
        That is, the algorithm avoids to traverse the list to find the correct spot to insert the new element.
        On the other hand, the queue needs only to perform one operation to put the new element in the head.
        Thus, we can reach the best case with a distribution of priorities where the numerical value descends from a higher one.
    \item \textbf{Worst Case $\mathcal{O}(n)$} --
        The worst case happens when the implementation traverse through the entire list, or $n$-times, to insert the new element in the correct place.
        Thus, the implementation reaches the worst case scenario with priority distribution of the same numerical value, because the queue uses FIFO policy to manage elements of the same priority.
\end{itemize}

\subsubsection{Doubly Linked List}
This algorithm uses a doubly linked list data structure.
An element stores 1) a unique number identifier, 2) priority and 3-4) two pointers that connect to the next and previous element in the queue.
The enqueue-operation of new elements takes place in the rear.
The following examines the time complexity of the algorithm:
\begin{itemize}
    \item \textbf{Best Case $\mathcal{O}(1)$} --
        The algorithm achieves the best case when the priority distribution consists of the same number because the queue applies FIFO to manage elements of the same priority.
        Thus, it requires only one operation to insert the new element.
    \item \textbf{Worst Case $\mathcal{O}(n)$} --
        The queue reaches the worst case when the priority's numerical value continually descends from a higher one.
        Thus, the algorithm traverses the list from the rear $n$-times to insert the new element correctly.
\end{itemize}

\subsubsection{Doubly Linked List with Modification}
This queue is similar to the previous section's implementation.
That is an element stores the same properties as the last one.
However, for this algorithm, the insertion of new elements takes place in either the head or rear.
The enqueue-operation depends on the average of the first and last element in the list.
The following list demonstrates the enqueue rules of the modified version:
\begin{itemize}
    \item In the head -- New element has a higher priority than the mean value, that is, \\numerical value $<$ mean value.
    \item In the rear -- New element has a lower or equal priority to the mean value, that is,\\numerical value $\ge$ mean value.
\end{itemize}

\skippara We analyzed the best and worst case for this implementation.
The following summarizes the analysis:
\begin{itemize}
    \item \textbf{Best Case $\mathcal{O}(1)$} --
       For the best case, we can either design the distribution of priorities to take place in either head or rear.
       For example, let us say that we create a distribution of the same priority.
       The average will always be the same as the new element's priority.
       Thus, the insertion for each of new elements takes place in the rear.
    \item \textbf{Worst Case $\mathcal{O}(n)$} --
        To achieve the worst case, we must traverse through the list for each insertion of a new element.
        It is achievable if the queue, for example, first enqueues two elements with significantly differing priorities.
        One with a high priority, and another with significantly lower priority.
        The average will skew towards the lower priority, that is, a notably high numerical value.
        Thus, if for each new element, it receives a lower priority than the previous one, then the insertion takes place in the head and traverses $(n - 1)$-times to insert new element correctly in the queue.
\end{itemize}

\subsubsection{Scheduling Queue}
This queue uses a static list, which consists of 41 pointers.
These entries represent the priority in the [0, 40] interval, and each pointer connects to an FIFO-queue.
A singly linked list represent each of the FIFO-queues, as described in \cref{sec:singly}.
The following list presents the time complexity for the best and worst case:
\begin{itemize}
    \item \textbf{Best Case $\mathcal{O}(n)$} -- The algorithm achieve the best time complexity if we distribute the elements equally in the queue.
        The simplest distribution enqueues elements from highest to the lowest priority and resets from lowest.
        That is, from priority 0 to 40, and then start over again from priority 0.
        However, when the implementation starts over from priority 0, the enqueue operation still has to traverse through the FIFO-queues to insert the new elements correctly.
        For example, if we assume that the elements are distributed equally, we can represent the running time as:
        \begin{equation*}
            1 + \left\floor{\frac{n}{41}\right}
        \end{equation*}
        The one represents the cost to access the priority queue.
        The rest represents the cost to traverse through the list.
    \item \textbf{Worst Case $\mathcal{O}(n)$} -- The algorithm achieves the same worst case the singly linked list, which we described in \cref{sec:singly}.
        That is, the implementation traverse $n$-times for a priority distribution of the same priority.
\end{itemize}


% Testb\"{a}dd eller Experimentuppst\"{a}llning. Ocks\r{a} en rubrik specifik f\"{o}r den h\"{a}r unders\"{o}kningen – men ocks\r{a} vanlig i m\r{a}nga unders\"{o}kningar d\"{a}r man utv\"{a}rderar ett tekniskt system.

% H\"{a}r beskriver du mer i detalj din experimentuppst\"{a}llning. Vilken h\r{a}rdvara, OS har du k\"{o}rt p\r{a}. Hur har du f\"{o}rs\"{o}kt minimera felk\"{a}llor (sominverkan av andra anv\"{a}ndare).
% Beskriv de testfall du anv\"{a}nt och implementerat. Argumentera f\"{o}r varf\"{o}r de \"{a}r rimliga/bra.
\subsection{Experimental Setup}\label{sec}
We plan to conduct the experiments on a Microsoft Azure virtual private server (VPS).
We use a VPS service to gain full access to the machine.
The system consist of a 64-bit architecture virtual CPU with two cores (Intel(R) Xeon(R) CPU E5-2673 v4 @ 2.30GHz), 8 GB memory and Ubuntu 16.04.3 LTS (Xenial Xerus) operating system.

\subsubsection{Error Sources}
Error sources are important to take into account as these can influence the results of the study.
That is, if we identify error sources early in the planning phase, we can then mitigate unexpected behaviors and results.
Software and computational research depend heavily on the underlying system, both hardware, and software.
Thus, we will run the experiments multiple times and calculate statistical features, such as mean and standard deviation for the sample.
Standard deviation is relevant because we can then identify how the execution time varies around the mean.
A large standard deviation could indicate, for example, that another process use a significant quantity of resources.

\skippara Another error source comes from poor design and implementation of
models.  Thus, we must grasp and follow scientific method rigorously, verify
and validate the implementations.  For example, a developer wastes time to
debug an implementation due to poor design, especially in a relatively
low-level programming language, such as \texttt{C}.

\subsubsection{Verification and Validation}
We will use a test case to verify the implementation' correctness, specifically the dequeue- and enqueue-operation to insert new elements at the correct position in the queue.
A Python script will be used to generate an input- and output file.
The former will consist of elements of randomized priorities and the output file contain the elements in correct order.
The input and output files can then be used to verify the correctness of the implementation.
We plan to use Valgrind to verify the memory allocation and deallocation of our implementations.

\skippara We will test for the best, average and worst cases to validate its behavior.
That is, we need to analayze the running time and complexity theoretically.
Also, used statistical analysis and complexity theory to validate the algorithms.
Finally, we will examine the edge cases, for example, an empty or a list containing only one element.

% Beskriv och motivera de experiment du designat (var noga att motivera varf\"{o}r de bidrar till att uppfylla m\r{a}len)
\clearpage
\subsubsection{Experiments}
To test the best, average and worst case, we will create a variety of priority distributions as input based on our complexity analysis of our algorithms. The analysis takes place in \cref{sec:algorithms}.
We did not analyze the time complexity for the average case theoretically.
However, we assume the average case lies somewhere between the best and worst case.
Thus, we will randomly assign priorities in $[0, 40]$ interval to the elements in the average case experiments.
Finally, \cref{tab:param} presents the remaining parameters we will use for each test case.


\begin{table}
    \small
    \caption{Experiment parameters for each implementation and test case}
    \label{tab:param}
    \begin{adjustbox}{center}
        \renewcommand*\arraystretch{1.2}\begin{tabular}{| L{3.5cm} || L{5.5cm} |}
            \hline
            \textbf{Iterations} & 50
            \\ \hline
            \textbf{Elements} & 10 000 -- 60 000 (multiples of 5000)
            \\ \hline
        \end{tabular}
    \end{adjustbox}
\end{table}


\skippara The following list summarizes the element's priority distribution, where $N$, $p$ and $n$ represent a set of elements, a numerical priority and the number of elements, respectively:
\clearpage
\begin{itemize}
    \item \textbf{Singly linked list}
        \begin{itemize}
            \item Best case -- Each element's priority increases linearly, for example,
                \begin{equation*}
                    N = \Big\{p_1, (p-1)_2, (p-2)_3, (p-3)_4,...,(p-n)_n \, \Big| \, p \ge n \ge 0 \Big\}
                \end{equation*}
            \item Worst case -- Each element's priority is the same, for example,
                \begin{equation*}
                    N = \Big\{p_{n} \, \Big| \, p \ge 0,\ n \ge 0 \Big\}
                \end{equation*}
        \end{itemize}
    \item \textbf{Doubly linked list}
        \begin{itemize}
            \item Best case -- Each element's priority is the same, for example,
                \begin{equation*}
                    N = \left\{p_{n} \, \Big| \, p \ge 0,\, n \ge 0 \right\}
                \end{equation*}
            \item Worst case -- Each element's priority increases linearly, for example,
                \begin{equation*}
                    N = \Big\{p_1, (p-1)_2, (p-2)_3, (p-3)_4,...,(p-n)_n \, \Big| \, p \ge n\ge 0 \Big\}
                \end{equation*}
        \end{itemize}
    \item \textbf{Doubly linked list with modification}
        \begin{itemize}
            \item Best case -- Each element's priority is the same, for example,
                \begin{equation*}
                    N = \left\{p_{n} \, \Big| \, p \ge 0,\, n \ge 0 \right\}
                \end{equation*}
            \item Worst case -- Insert two elements with significant difference in priority to skew the average.
                Then, linearly decrease the priority from one with the highest one, for example:
                \begin{equation*}
                    \resizebox{.9\hsize}{!}{$N = \left\{p_1, (p*2)_2, (p+1)_3, (p+2)_4, (p+3)_5,..., (p+n-2)_{(n-2)} \, \Big| \, p \ge n \ge 3 \right\}$}
                \end{equation*}
        \end{itemize}
    \item \textbf{Scheduling queue}
        \begin{itemize}
            \item Best case -- The element's priority is equally distributed, for example,
                \begin{equation*}
                    \resizebox{.9\hsize}{!}{$N = \left\{\left((p+1) \bmod 41\right)_1, \left((p+2) \bmod 41\right)_2,..., \left((p+n) \bmod 41\right)_n \, \Big| \, 0 \le p \le 40, \, n \ge 0\right\}$}
                \end{equation*}
            \item Worst case -- Each element's priority is the same, for example,
                \begin{equation*}
                    N = \left\{p_{n} \, \Big| \, p \ge 0,\, n \ge 0 \right\}
                \end{equation*}
        \end{itemize}
\end{itemize}





\appendix
\addappheadtotoc
\chapter{Requirement Analysis}\label{app:A}

In \cite{web:requirementoverview}, the author describes that a requirement analysis is a summary of all the requirement the researcher can find.
The author clearly states that this document is \emph{not} about how one should implement something to achieve a specific requirement.
On the contrary, it should only cover the meaning of the requirement.
Thus, we need to set up requirements that describes how to pass the task about the scientific method, specifically experimental quantitative method, as shown in \cref{tab:requirement}.

{\footnotesize
    \begin{longtable}{ |P{2cm}||P{1.7cm}|P{2.2cm}|P{4.3cm}|P{2.3cm}| }
        \caption{Requirement analysis about the scientific method} \label{tab:requirement}\\
        \hline
        Requirement number & Requirement type & Name or source & Clarified description of the requirement, followed by what should be fulfilled& Fulfilled or not fulfilled or partly fulfilled\\
        \hline
        1 & \textbf{Must} mandatory task & Purpose \cite{A3Experi4:online} & Ask good questions and identify the purpose. That is, why is it necessary to conduct an experimental evaluation of algorithms, and what is the application of it. The specific task description is described in \cite{Uppgiftl9:online}. & Fulfilled \cref{sec:purpose}\\
        \hline
        2 & \textbf{Must} mandatory task & Prestudy \cite{A3Experi4:online} & Demonstrate an understanding about the task and field of study. Also, identify which parameters to use, how these can depend on and vary from each other & Fulfilled \cref{sec:background}\\
        \hline
        3 & \textbf{Must} mandatory task & Methods \cite{A3Experi4:online} & Identify which scientific method(s) to use. For example, quantitative, qualitative, deductive and/or inductive method & Fulfilled \cref{sec:methods}\\
        \hline
        4 & \textbf{Must} mandatory task & Experimental Plan \cite{A3Experi4:online} & Identify experiments to conduct. Describe why these are relevant. Examine metrics to measure and elaborate on why these are relevant to this study. & Fulfilled \cref{sec:algorithms}\\
        \hline
        5 & \textbf{Must} mandatory task & Experimental Setup \cite{A3Experi4:online} & Describe in details the resources needed. Identify and examine the influence of error sources, both external and internal ones. Set up an implementation, verification and validation plan. & Fulfilled \cref{sec:setup}\\
        \hline
        6 & \textbf{Must} mandatory task & Goals \cite{A3Experi4:online} & Demonstrate how to determine when a goal is reached and an experiment is completed. & Fulfilled \cref{sec:goal}\\
        \hline
        7 & \textbf{Must} mandatory task & Communication Part \RN{1} \cite{A3Experi4:online} & Communicate and summarize the discussions of requirement 1-6 (\cref{app:A}) in a document and hand it in to the mentor/supervisor & Fulfilled \\
        \hline
        8 & \textbf{Must} mandatory task & Experimental Execution \cite{A3Experi4:online, Uppgiftl9:online} & Follow the discussed requirements 1-6, or only 7, to conduct the experiments on a real system. And, regularly document the findings with honesty and transparency. & \\
        \hline
        9 & \textbf{Must} mandatory task & Communication Part \RN{2} \cite{A3Experi7:online} & Summarize the entire work and its requirements, that is 1-8, in a smaller version of a technical report. Use the IMRAD-structure (Introduction, Method, Results, and Discussion). It is a common communication structure in scientific reports. & \\
        \hline
\end{longtable}}

\clearpage
% H\"{a}r listar du dina referenser. De skall t\"{a}cka in alla relevanta delar  i din bakgrund, vara v\"{a}l utvalda (dvs. h\r{a}lla f\"{o}r k\"{a}llkritik).
%
% I den h\"{a}r rapporten anv\"{a}nder du ISO690 numerisk variant f\"{o}r referenserna.
%
% Har man ett bra verktyg som man skriver i/hantera referenserna i s\r{a} kan referenslistan automatgenereras. Det g\"{o}r det ocks\r{a} l\"{a}ttare att uppdatera referenslistan utan att beh\"{o}va g\r{a} igenom varje referens i texten manuellt. Dessutom f\r{a}r man bara med k\"{a}llor som man refererat till minst en g\r{a}ng fr\r{a}n texten.
\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,sources}
\end{document}
