\documentclass[a4paper,11pt]{kth-mag}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{lmodern}
\usepackage[latin1]{inputenc}
\usepackage[swedish,english]{babel}
\usepackage{modifications}
\usepackage{mathtools}
\usepackage{pgfplotstable, booktabs}
\usepackage{color, colortbl}
\usepackage{adjustbox}
\usepackage{graphicx} % Required to insert images
\usepackage[colorlinks=true, citecolor=magenta, linkcolor=magenta]{hyperref}
\usepackage[nameinlink, capitalise]{cleveref}
\newcommand{\RN}[1]{%
      \textup{\uppercase\expandafter{\romannumeral#1}}%
  }
\usepackage{longtable}
\newcommand\fnurl[2]{%
    \href{#1}{#2}\footnote{\url{#1}}%
}
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\newcommand\floor[1]{\lfloor#1\rfloor}

\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\usepackage{lmodern}  % for bold teletype font
\usepackage{amsmath}  % for \hookrightarrow
\usepackage{xcolor}   % for \textcolor
\usepackage{listings}
\lstset{
    basicstyle=\tiny\ttfamily,
    columns=fullflexible,
    showstringspaces=false,
    frame=single,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}



% För formateringen av en rapport/artikel finns ofta färdiga mallar. Publicerar man t.ex. en artikel på en konferens eller i en tidskrift finns mallar/anvisningar som beskriver vilka typsnitt, storlekar, radavstånd, marginaler paragrafnumrering etc. som skall användas.
% Ofta beskrivs också hur lång texten får vara i antal ord och antal sidor.
% För den här uppgiften skall texten ligga mellan 7 och 12 sidor oräknat försättsblad, Abstract, sammanfattning, referenslista och bilagor.

% Den här rapportmallen beskriver vad man kan förvänta sig finna i en teknisk rapport som baseras på någon form av undersökning/utredning. De rubriker/stycken som är beskrivna är de som återfinns i de allra flesta rapporter. För längre rapporter delar man ofta upp rapporten i flera stycken med egna rubriker. T.ex. kanske man beskriver flera olika experiment och experimentuppställningar.

% I rapporten kan och bör du återanvända delar av det du skrivit i din projektplanering.

% Försättssida: Titeln skall vara deskriptiv/informativ. Sätts i Arial 14 punkter fet stil (KTH titel)

% Försättssida: Här anger man namn på alla författare, titlar och kontaktinformation
\title{Priority Queues Experiment}
\subtitle{December 3, 2017}
\foreigntitle{Lorem ipsum dolor sit amet, sed diam nonummy nibh eui mod tincidunt ut laoreet dol}
\author{Wong, Sai Man\\ Tigerstr\"{o}m, Gabriel}
\date{November 2016}
\blurb{}
\trita{}
\newcommand*{\skippara}{\par\vspace{\baselineskip} \noindent}
\begin{document}
\frontmatter
\pagestyle{empty}
\removepagenumbers
\maketitle
\selectlanguage{english}

% Ny sida- startar på högersida: I examensarbetsrapporter på KTH skall det finnas sammanfattning på både svenska och engelska (Abstract). Rubriken sätts i Arial 12 punkter fet stil ( KTH rubrik), brödtexten som  Times New Roman 10 punkter (KTH Brödtext)
\begin{abstract}
This is a skeleton for KTH theses. More documentation
regarding the KTH thesis class file can be found in
the package documentation.

Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Mauris
purus. Fusce tempor. Nulla facilisi. Sed at turpis. Phasellus eu
ipsum. Nam porttitor laoreet nulla. Phasellus massa massa, auctor
rutrum, vehicula ut, porttitor a, massa. Pellentesque fringilla. Duis
nibh risus, venenatis ac, tempor sed, vestibulum at, tellus. Class
aptent taciti sociosqu ad litora torquent per conubia nostra, per
inceptos hymenaeos.
\end{abstract}
\clearpage

% Ny sida, startar på högersida. Sammanfattning och Abstract skall innehålla samma text men på olika språk. Sammanfattningen skall översiktligt beskriva vad rapporten innehåller och de viktigaste resultaten. Den hålls normalt ganska kortfattad (1/4-1/2 A4 sida text. De skrivs på separata sidor.
\begin{foreignabstract}{swedish}
Denna fil ger ett avhandlingsskelett.
Mer information om \LaTeX-mallen finns i
dokumentationen till paketet.

Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Mauris
purus. Fusce tempor. Nulla facilisi. Sed at turpis. Phasellus eu
ipsum. Nam porttitor laoreet nulla. Phasellus massa massa, auctor
rutrum, vehicula ut, porttitor a, massa. Pellentesque fringilla. Duis
nibh risus, venenatis ac, tempor sed, vestibulum at, tellus. Class
aptent taciti sociosqu ad litora torquent per conubia nostra, per
inceptos hymenaeos.
\end{foreignabstract}
\clearpage

% Om man har ett bra verktyg som man skriver sin rapport i och man använder väldefinierade paragraf/stilmallar så kan innehållsförteckningen oftast automatgenereras
{
    \hypersetup{linkcolor=black}
    \tableofcontents*
}
\mainmatter
\pagestyle{newchap}

% ///////////////////////////////////
% ///////////////////////////////////
%           Introduction
% ///////////////////////////////////
% ///////////////////////////////////

% Huvudrubriker sätts i Arial 12 punkter fet stil autonumrerad (KTH nRubrik 1). Här introducerar man problemomådet. Här skall finnas en bakgrund till projektet, de problem man adresserar/undersöker och syftet med arbetet.De olika underkapitlen/styckena till introduktionen  förtydligar det du skriver här. Här förväntar man sig hitta ett antal noga utvalda hög-kvalitativa referenser.
\chapter{Introduction}
A researcher plan in advance to conduct a successful and credible scientific work.
However, students and engineers occasionally approach the planning phase in a careless manner.
As a result, researchers waste time to redo the changes due to poor design and execution.
Students and engineers lack a deeper knowledge of the scientific method to contribute with quality work.
That is, science emphasizes the importance of theoretical knowledge and its application in practice.
Thus, in our study, we used the scientific method to evaluate algorithms with a rigorous, honest and transparent method.

% Underrubriker (första nivån) sätts i Arial 12 punkter fet stil autonumrerad (KTH  nRubrik 2). (Har man ytterligare undernivåer sätter man rubrikerna för nästa nivå  med (KTH nRubrik 3)) Man försöker ofta begäränsa sig till tre nivåer på rubriker och man har i princip aldrig fler än 4 nivåer på rubriker.
%I stycket om bakgrund (som ibland kallas ”Related work” på engelska) förväntar man sig hitta en gedigen bakgrundsbeskrivning till problemområdet i stort och till det specifika problem som studeras i rapporten. Den skall innehålla/baseras på en litteraturstudie. Det behöver väl knappast påpekas att den bör innehålla utvalda, högkvalitativa referenser.
\section{Background}
A data structure represent a model to store data with a methodical approach \cite{deshpande2004c}.
Software engineers use queues in software development to manage arbitrary entities in a first-in-first-out (FIFO) order.
For example, developers use a queue to develop a memory buffer or scheduling in an operating system.

\skippara Higher level programming languages often provide a standardized library with finished implementations, such as a queue.
Software developers use these implementations frequently, and sometimes take the underlying architecture for granted.
Thus, an inexperienced developer possess a limited knowledge of the theory and technical aspects of the used implementations.

\skippara Developers use the data structure, or model, linked list to store data linearly.
The simple linked list consists of entities.
An entity stores data and includes a connection to the next entity in the list.
Computer scientist and developers refer the entity as a node or an element, and the connection as a pointer.
That is, an element stores data and consists of a pointer to the next element in the list.
Thus, developers frequently use linked list implementations to store and manage data linearly, for example, in a queue implementation.


% Här beskriver du problemområdet och problemet i detalj. Beskriv också varför det är värdefullt att undersöka problemet. Försök formulera din problemställning så klart och koncist som möjligt – gärna i en mening!
\section{Problem}\label{sec:problem}
An engineer must learn the skill to apply the scientific method in practice.
That is, to later on possess the ability to contribute with further development and exploration within the scientific community.
Also, a software engineer needs to grasp the basics of features in an API\footnote{API -- Application Programming Interface}-library.
However, developers sometimes use these library features in projects, and take these algorithms for granted to behave in a specific manner.
Thus, we applied the scientific method rigorously to evaluate algorithms in depth, both in theory and practice.

\skippara Our task was to evaluate four variations of a list-based data structure to represent a queue \cite{Uppgiftl9:online}.
Each element compromises of a number to represent its priority in the queue.
For clarification, an element with a low number represents higher priority, because the element lies closer to the present time and therefore ready for execution.
We implemented the queues in the low-level programming language \texttt{C}, and the following list presents the implementation specifications:
\begin{enumerate}
    \item \textbf{Singly linked list} -- Insertion of new elements takes place in the head.
    \item \textbf{Doubly linked list} -- Insertion of new elements takes place in the rear.
        \item \textbf{Doubly linked list} -- Insertion of new elements takes place based on the mean of the first and last element's priority.
        \begin{itemize}
            \item In the head -- The new element's priority is higher than the mean, that is, \\numerical value $<$ mean value.
            \item In the rear -- The new element's priority is lower than the mean, that is,\\numerical value $\ge$ mean value.
        \end{itemize}
    \item \textbf{Scheduling queue} -- The queue consists of an FIFO-queue for each priority in the $[0,40]$ interval.
\end{enumerate}

\skippara
Computer scientists evaluate algorithms in terms of space and time, such as execution time and memory usage.
That is, we gather a large quantity of these metric to determine best, average and worst cases.
Thus, we asked ourselves: ``Do these queues achieve similar performance, or does the performance vary depending on the circumstance?''


\clearpage
% Om detta är en studie där syftet är att undersöka en hypotes (alla projekt är inte hypotesprövande) så beskriver du/formulerar du hypotesen här. Lämpligt är också att beskriva hur/varför/på vilka grunder du formulerat hypotesen. Är det inte ett hypotesprövande projekt så tar du bort rubriken.
\section{Hypothesis}
A queue either enqueues or dequeues elements with an FIFO policy.
Because of the FIFO policy, we assumed with a correct implementation and theory, the dequeue-operation take $\mathcal{O}(1)$ time.
However, the enqueue-operation becomes more sensitive to an element's priority, because the algorithm insert each element in the correct spot in the queue.
Thus, the implementations perform differently because of priority distribution.
For example, the implementation reaches $\mathcal{O}(n)$ time if the algorithm traverses through the entire list to enqueue an element.

\skippara The following list describes our hypotheses:
\begin{itemize}
    \item The dequeue-operation for all the queues takes $\mathcal{O}(1)$ time.
    \item The enqueue-operation for all the queues takes $\mathcal{O}(n)$ time.
\end{itemize}

% Beskriv varför projektet genomförs.
\section{Purpose}
Our purpose was to raise awareness of the features in API-libraries with the scientific method, which developers and engineers often take for granted.
Thus, we conducted experiments to achieve a deeper knowledge to apply the scientific method, and to evaluate four versions of a queue implementation.
Consequently, we wanted to contribute with a study students and engineers can learn from and further develop.

% Beskriv de förväntade resultat- och effektmålen av undersökningen. Beskriv alla mål du satt upp även om de inte nåddes!
\section{Goal}
The bigger goal was to attain deeper knowledge of the scientific method, and apply the method to evaluate four queue-implementations.
However, the following list demonstrates the sub-goals:
\begin{itemize}
    \item Apply scientific method to plan, design, experiment, document, analyze and present the findings.
    \item Grasp the importance of scientific method.
    \item Conduct a reproducible study.
    \item Attain the ability to present, analyze and draw conclusions from experiments, both in theory and practice.
    \item Implement queues correctly, that is, verify its behavior and validate the data.
    \item Create tests to generate the execution time and memory usage from the algorithms.
\end{itemize}

% Beskriv vem och på vilket sätt man kan ha nytta av utredningen. Beskriv etiska och hållbar utvecklingsrelaterade frågor kopplade till utredningen.
\section{Social Benefit, Ethics and Sustainable Development}
Our study influence students and engineers to apply the scientific method more with a more serious approach.
Also, the study facilitate the process for software engineers to choose an implementation of a queue, which fits their specific purpose.
Finally, we delve into the foundations of algorithms, data structure and complexity theory.
Thus, our work help students and engineers to acquire a deeper comprehension of computer science.

\skippara Within science, a researcher undertake a moral responsibility to conduct a reproducible work with honesty and transparency.
However, sometimes scientists encounter difficult circumstances, which limits their ability to produce a reproducible work.
For example, due to economical and practical reasons, such as expensive hardware.
We documented each step and presented findings with rigor, honesty and transparency.
That is, we encourage students to reproduce our findings.

\skippara We conducted the experiment on a virtual machine on Microsoft's cloud platform.
Thus, we used the exact quantity of resources needed to conduct the experiments.
That is, we avoided to waste unnecessary electricity due to, for example, system idle.



% I större, mer omfattande rapporter med flera stycken lägger man ibland till en översikt Disposition (Overview) som beskrivar vad läsaren kommer att hitta i de olika styckena. Syftet är att hjälpa läsaren få en översikt över rapporten så han/hon kan hitta snabbt i den.
\section{Outline}



% ///////////////////////////////////
% ///////////////////////////////////
%       Method
% ///////////////////////////////////
% ///////////////////////////////////

% I metoelen beskriver du den vetenskapliga metod du baserat ditt projekt på.
%
% Vilka relevanta metoder finns? Vilka har du övervägt att använda? Varför valde du den/de metoder du använt?
%  Beskriv kort den metod du använt och hur du applicerat den - dvs. vilken data du samlar in, hur du gör det och varför. Beskriv också tillförlitligheten hos data du samlar in. Går experimenten att upprepa? Finns etiska eller HU aspekter på ditt arbete.
\chapter{Method}

\section{Inductive and Deductive Method}
Scientists apply an inductive method to reach practical conclusions from observations or data \cite{Omexperi69:online}.
That is, in sequential order to 1) collect data, 2) detect pattern in the data, 3) set up a hypothesis and 4) explain the findings with established theory to reach 5) a conclusion \cite{web:induction}.
The method is sometimes informally called a bottom-up approach due to its style to first observe data.
Software engineers frequently apply an inductive method to observe algorithms and a system's behavior.
For example, a developer put in a specific input in the implementation and generate an output to observe the algorithm's performance.

\skippara With the deductive method, also called top-down approach, scientists reach logical conclusions from theory first.
For example, mathematicians use a deductive method to explain the unknown with help of established theory (axioms and theorems).
A deductive method also applies to researchers within computer science.
That is, computer scientists use mathematical notations to represent theoretical models in, for example, algorithm analysis and complexity theory.
Thus, researchers use these methods for a variety of purposes, and sometimes combine them to reach both a logical and practical conclusion.

\section{Quantitative and Qualitative Method}

Researches apply a quantitative method in studies, which rely on measurable data in large quantities to explain findings \cite{haakansson2013portal}.
That is, a quantitative study use measurable metrics, such as time, temperature and age.
These studies apply statistical analysis to summarize the data in tables and graphs with error margins.
For example, scientists use a quantitative method to predict a nation's growth based on the birth and death rate over a longer period.

\skippara In contrast, a qualitative method relies on data of quality to interpret the results \cite{merriam2009qualitative}.
Scientists use a qualitative method in studies when the data is significantly more difficult to quantify, such as opinions, thoughts and happiness.
The researchers conduct, for example, interviews and surveys, to collect data from individuals.
Thus, psychologists often implement a qualitative method to examine people's behavior.

% Beskriv hur du samlar in data, material och annat underlag för din undersökning? Svara på frågor som: Hur skall undersökningen genomföras? Hur är experimentuppställningen organiserad?
\section{Data Collection}
We used quantifiable metrics in our study.
That is, execution time and memory usage, because computer scientists commonly apply these for algorithm och complexity analysis.
In contrast to, for example, interviews and surveys, which the researchers within social sciences regularly use in qualitative studies \cite{Omexperi69:online, haakansson2013portal}.
That is, qualitative studies reaches conclusions from the quality of the data.
Thus, our study uses an experimental quantitative method to reach a deeper insight into data structures and queue implementations.

\skippara For each of the four queue-implementations, we tested and generated the execution time for the best, average and worst case.
That is, we created input for the queues with varying distributions of the element's priorities.
Besides execution time, we log the memory usage for each implementation.
Finally, we wrote scripts to execute the tests and logged the raw data.

% Beskriv metoden för hur du avser analysera insamlad data/material. Beskriv också hur du planerar tolka  data
\section{Data Analysis}
We reasoned with a deductive method to explore the theory within computer science, such as algorithm complexity theory.
That is, we analyzed the algorithms with help of established complexity theory.
For example, to determine an algorithm's performance based solely on theoretical knowledge.
However, the usage of only a deductive methods can yield unexpected results when put into practice.
Thus, we generate realistic data from our experiments, and use an inductive method to further analyze the algorithms.
That is, to explore if we can notice observable patters in the data with help of complexity models.

\skippara We used both graphs and tables to visualize the execution time and memory usage.
And, ran the experiments multiple times to generate the sample mean and standard deviation.
The standard deviation adds a deeper insight into the data and spread around the mean.
Also, it help us to identify the external or internal error sources.
If the standard deviation is relatively high, then we can suspect that something is wrong with, for example, the underlying system.





% ///////////////////////////////////
% ///////////////////////////////////
%       System Description
% ///////////////////////////////////
% ///////////////////////////////////

% Ett kapitel om Systembeskrivning / Konstruktion eller i detta fall Experimentuppställning  finns inte med i alla studier men ofta i tekniska rapporter där man konstruerat ett system. Den här delen kan vara ett kapitel/stycke eller flera beroende på hur stort arbete man gjort.

% Här startar man normalt med en beskrivning av det/de system man utvecklat och /eller haft som underlag i studien.
\chapter{System Description}


% Om du utvecklat ett system (som algoritmerna för den här studien) så bör du beskriva vilken/vilka metoder och verktyg du använt för systemutvecklingen. I större undersökningar/arbeten vill man gärna också se en diskussion om olika alternativ och varför man valt de man använt.
\section{System Development Method}
Our implementation produces an executable for each of the four queue-implementations.
The experiment consists of primarily three files, \texttt{main.c} with the tests, \texttt{queues.h} and \texttt{queues.c} which respectively describes and implements the functionalities of the queue.
Finally, we used compile time macros to determine which of the four queue-implementation we create an executable from.

\skippara We used Bash-scripts to automatically run tests and log the results in plain text.
Also, we developer a Python-script, which 1) calculated the sample mean and standard deviation, and 2) summarized and visualized the data with tables and graphs in \LaTeX.\
Finally, we used Valgrind on our implementations to examine memory allocation and deallocation.

\skippara We added an optional solution to run the entire experiment in a container.
That is, if anyone wants to run the entire experiment, and spend minimum time on the setup process, then the user only has to install Docker and execute a command to achieve the similar results we produced.
Docker containers introduce an effective approach to package software, because containers use the same resources as the host operating system.


% Det här är en anpassad rubrik för just den här studien. Här beskriver du (ev. med flera underrubriker) mer i detalj de algoritmer du implementerat, analyserar dem och hur du implementerat dem.
\section{Queue Algorithms}\label{sec:algorithms}
Our task is to implement four different queue-implementation in the programming language \texttt{C}, as described in \cref{sec:problem}.
The following are common operations for a queue:
\begin{itemize}
    \item \textbf{Enqueue} -- enqueues the element in the correct spot in the priority queue.
    \item \textbf{Dequeue} -- dequeues the element with the highest priority, that is, the first element in the queue.
\end{itemize}

\skippara The queues approach to enqueue varies for the implementations, because the algorithm traverses and inserts the new element in the correct position in the queue.
Each element stores at least 1) a unique number identifier of the data type integer, 2) a priority number of the data type double and 3) a pointer to refer to additional elements.

\skippara The following sections describe our implementation of the queues.
Additionally, we analyzed the time complexity for the enqueue-operation.
We found the average case time complexity more difficult to theoretically analyze compared to the best and worst case.
Thus, we examined the best and worst cases in theory to interpret the average case for each implementation's enqueue-operation.

\subsection{Singly Linked List}\label{sec:singly}
This queue implementation uses a singly linked list to represent a queue.
That is, an element in the queue stores 1) a unique number identifier, 2) a priority and 3) a pointer to the next element in the queue.
The algorithm enqueues new elements from head.
The following list analyzes the enqueue-operation's time complexity:
\begin{itemize}
    \item \textbf{Best Case $\mathcal{O}(1)$} -- The best case occurs when the enqueue-operation of new elements always takes place in the head.
        That is, the algorithm avoids to traverse the list to find the correct spot to insert the new element.
        On the other hand, the queue needs to only perform one operation to put the new element in the head.
        Thus, we can reach the best case with a distribution of priorities where the numerical value descends from a higher one.
    \item \textbf{Worst Case $\mathcal{O}(n)$} -- The worst case happens when the implementation traverse through the entire list, or $n$-times, to insert the new element in the correct place.
        Thus, the implementation reaches the worst case scenario with priority distribution of the same numerical value, because the queue uses FIFO policy to manage elements of the same priority.
\end{itemize}

\subsection{Doubly Linked List}
This algorithm uses a doubly linked list data structure.
An element stores 1) a unique number identifier, 2) priority, and 3-4) two pointers that connects to next and previous element in the queue.
The enqueue-operation of new elements takes place in the rear.
The following examines the time complexity of the algorithm:
\begin{itemize}
    \item \textbf{Best Case $\mathcal{O}(1)$} -- The algorithm achieves the best case when the priority distribution consists of the same number.
        Because, the queue applies FIFO to manage elements of the same priority.
        Thus, it requires only one operation to insert the new element.
    \item \textbf{Worst Case $\mathcal{O}(n)$} -- The queue reaches the worst case when the priority's numerical value constantly descends from a higher one.
        Thus, the algorithm traverses the list from the rear $n$-times to insert the new element correctly.
\end{itemize}

\subsection{Doubly Linked List with Modification}
This queue is similar to the previous section's implementation.
That is, an element stores the same properties as the last one.
However, for this algorithm, the insertion of new elements takes place in either the head or rear.
The enqueue-operation depends on the average of the first and last element in the list.
The following list demonstrates the enqueue rules of the modified version:
\begin{itemize}
    \item In the head -- New element has a higher priority than the mean value, that is, \\numerical value $<$ mean value.
    \item In the rear -- New element has a lower or equal priority to the mean value, that is,\\numerical value $\ge$ mean value.
\end{itemize}

\skippara We analyzed the best and worst case for this implementation.
The following summarizes the analysis:
\begin{itemize}
    \item \textbf{Best Case $\mathcal{O}(1)$} -- For the best case, we can either design the distribution of priorities to take place in either head or rear.
        For example, let us say that we create a distribution of the same priority.
        The average will always be the same as the new element's priority.
        Thus, the insertion for each of new elements takes place in the rear.
    \item \textbf{Worst Case $\mathcal{O}(n)$} -- To achieve the worst case, we must traverse through the list for each insertion of a new element.
        It is achievable if the queue, for example, first enqueues two elements with significantly differing priorities.
        One with a high priority, and another with significant lower priority.
        The average will skew towards the lower priority, that is, a notably high numerical value.
        Thus, if for each new element, it receives a lower priority than the previous one, then the insertion takes place in the head and traverses $(n-1)$-times to insert new element correctly in the queue.
\end{itemize}

\subsection{Scheduling Queue}
This queue uses a static list, which consists of 41 pointers.
These entries represent the priority in the [0, 40] interval, and each pointer connects to an FIFO-queue.
A singly linked list represent each of the FIFO-queues, as described in \cref{sec:singly}.
The following list presents the time complexity for the best and worst case:
\begin{itemize}
    \item \textbf{Best Case $\mathcal{O}(n)$} -- The algorithm achieve the best time complexity if we distrubute the elements equally in the queue.
        The simplest distribution enqueues elements from highest to the lowest priority and resets from lowest.
        That is, from priority 0 to 40, and then start over again from priority 0.
        However, when the implementation starts over from priority 0, the enqueue operation still has to traverse through the FIFO-queues to insert the new elements correctly.
        For example, if we assume that the elements are distributed equally, we can represent the running time as:
        \begin{equation*}
            1 + \left\floor{\frac{n}{41}\right}
        \end{equation*}
        The one represents the cost to access the priority queue.
        The rest represents the cost to traverse through the list.
    \item \textbf{Worst Case $\mathcal{O}(n)$} -- The algorithm achieves the same worst case the singly linked list, which we described in \cref{sec:singly}.
        That is, the implementation traverse $n$-times for a priority distribution of the same priority.
\end{itemize}


% Testbädd eller Experimentuppställning. Också en rubrik specifik för den här undersökningen – men också vanlig i många undersökningar där man utvärderar ett tekniskt system.

% Här beskriver du mer i detalj din experimentuppställning. Vilken hårdvara, OS har du kört på. Hur har du försökt minimera felkällor (sominverkan av andra användare).
% Beskriv de testfall du använt och implementerat. Argumentera för varför de är rimliga/bra.
\section{Experimental Setup}
We conducted the experiments on a Microsoft Azure virtual private server (VPS).
We used a VPS service because we gain full access over the machine.
The system consisted of a 64 bit architecture virtual CPU with two cores (Intel(R) Xeon(R) CPU E5-2673 v4 @ 2.30GHz), 8 GB memory and Ubuntu 16.04.3 LTS (Xenial Xerus) operating system.

\subsection{Error Sources} Error sources are important to take into account as these can influence the results of the study.
That is, if we identify error sources early in the planning phase, we can then mitigate unexpected behaviors and results.
Software and computational research depend heavily on the underlying system, both hardware and software.
Thus, we run the experiments multiple times and calculate statistical features, such as mean and standard deviation for the sample.
Standard deviation is relevant, because we can then identify how the execution time vary around the mean.
A large standard deviation indicates, for example, that another process consume significant quantity of resources.

\skippara Another error source comes from poor design and implementation of models.
Thus, we must grasp and follow scientific method rigorously, verify and validate the implementations.
For example, a developer wastes time to debug an implementation due to poor design.
And, especially in a relative low-level programming language, such as C.

\subsection{Verification and Validation}
We developed a test case to verify the implementation' correctness, specifically the dequeue-operation to insert new elements at the correct position in the queue.
Our Python script generates an input- and output-file.
The former consists of elements of randomized priorities, and the output file contains the elements in correct order.
Finally, we used the input and output files in our implementations to verify its correctness.
We used Valgrind and verified the memory allocation and deallocation of our implementations.

\skippara We developed tests for the best, average and worst cases to validate its behavior.
That is, we analyzed the running time and complexity theoretically.
And, used statistical analysis and complexity theory to validate the algorithms.
Finally, we examined the edge cases, for example, an empty or a list containing only one element.

% Beskriv och motivera de experiment du designat (var noga att motivera varför de bidrar till att uppfylla målen)
\subsection{Experiments}
To test the best, average and worst case, we created a variety of priority distributions as input based on our complexity analysis of our algorithms.
The analysis takes place in \cref{sec:algorithms}.
We did not analyze the time complexity for the average case theoretically.
However, we assumed the average case somewhere lies between the best and worst case.
Thus, We randomly assigned priorities in $[0,40]$ interval to the elements in the average case experiments.
Finally, \cref{tab:param} presents the remaining parameters we used for each test case.

\begin{table}
    \small
    \caption{Experiment parameters for each implementation and test case}
    \label{tab:param}
    \begin{adjustbox}{center}
        \renewcommand*\arraystretch{1.2}\begin{tabular}{| L{3.5cm} || L{5.5cm} |}
            \hline
            \textbf{Iterations} & 50
            \\ \hline
            \textbf{Elements} & 10 000 -- 60 000 (multiples of 5000)
            \\ \hline
        \end{tabular}
    \end{adjustbox}
\end{table}


\skippara The following list summarize the element's priority distribution, where $N$, $p$ and $n$ represent a set of elements, a numerical priority and the number of elements, respectively:
illustrates
\clearpage
\begin{itemize}
    \item \textbf{Singly linked list}
        \begin{itemize}
            \item Best case -- Each element's priority increases linearly, for example,
                \begin{equation*}
                    N = \Big\{p_1, (p-1)_2, (p-2)_3, (p-3)_4,...,(p-n)_n \, \Big| \, p \ge n \ge 0 \Big\}
                \end{equation*}
            \item Worst case -- Each element's priority is the same, for example,
                \begin{equation*}
                    N = \Big\{p_{n} \, \Big| \, p \ge 0,\ n \ge 0 \Big\}
                \end{equation*}
        \end{itemize}
    \item \textbf{Doubly linked list}
        \begin{itemize}
            \item Best case -- Each element's priority is the same, for example,
                \begin{equation*}
                    N = \left\{p_{n} \, \Big| \, p \ge 0,\, n \ge 0 \right\}
                \end{equation*}
            \item Worst case -- Each element's priority increases linearly, for example,
                \begin{equation*}
                    N = \Big\{p_1, (p-1)_2, (p-2)_3, (p-3)_4,...,(p-n)_n \, \Big| \, p \ge n\ge 0 \Big\}
                \end{equation*}
        \end{itemize}
    \item \textbf{Doubly linked list with modification}
        \begin{itemize}
            \item Best case -- Each element's priority is the same, for example,
                \begin{equation*}
                    N = \left\{p_{n} \, \Big| \, p \ge 0,\, n \ge 0 \right\}
                \end{equation*}
            \item Worst case -- Insert two elements with significant different priority to skew the average.
                Then, linearly decrease the priority from one with the highest one, for example:
                \begin{equation*}
                    \resizebox{.9\hsize}{!}{$N = \left\{p_1, (p*2)_2, (p+1)_3, (p+2)_4, (p+3)_5,..., (p+n-2)_{(n-2)} \, \Big| \, p \ge n \ge 3 \right\}$}
                \end{equation*}
        \end{itemize}
    \item \textbf{Scheduling queue}
        \begin{itemize}
            \item Best case -- The element's priority is equally distributed, for example,
                \begin{equation*}
                    \resizebox{.9\hsize}{!}{$N = \left\{\left((p+1) \bmod 41\right)_1, \left((p+2) \bmod 41\right)_2,..., \left((p+n) \bmod 41\right)_n \, \Big| \, 0 \le p \le 40, \, n \ge 0\right\}$}
                \end{equation*}
            \item Worst case -- Each element's priority is the same, for example,
                \begin{equation*}
                    N = \left\{p_{n} \, \Big| \, p \ge 0,\, n \ge 0 \right\}
                \end{equation*}
        \end{itemize}
\end{itemize}

% ///////////////////////////////////
% ///////////////////////////////////
%              Results
% ///////////////////////////////////
% ///////////////////////////////////

% Här presenterar du dina resultat och slutsatser från undersökningen. Tänk på att presentera resultaten på ett tydligt sätt och ta med tillräckligt mycket i presentationen så att alla slutsatser är tydligt välgrundade. Lyft fram det som är mest intressant och viktigt.
\chapter{Results and Discussion}

\section{Running Time}
We visualized the running time results from the implementations with help of graphs and tables in \cref{app:singly}, \cref{app:doubly}, \cref{app:doublyavg} and \cref{app:arraypriority}.
That is, the singly linked list, doubly linked list, doubly linked list with modification and scheduling queue respectively.

\subsection{Enqueue}
Our running time results for the enqueue-operation shows that the worst case tests represent an upper bound limit of time complexity for each of the algorithms.
The same goes for best case tests, that is, these show a lower bound limit.
And the average case's time complexity lies somewhere between these limits.
Each implementation reaches similar time complexity in the best and worst case.
Finally, the singly and doubly linked list yielded similar running time for the average case.
That is, around 18 seconds with 60 000 elements.

\skippara The doubly linked list with modification and scheduling queue algorithms produced a lower running time in the average case tests.
That is, around 10 seconds and 1 second, respectively, for 60 000 elements.
The average case tests for the scheduling queue yielded running time that were only milliseconds higher than for its best case.
Whereas, the rest of implementations' average case tests produced running times that were several seconds higher than their best case.
That is, at least for more than 25 000 elements.

\subsection{Dequeue}

There were no significant changes in the results for the dequeue-operation experiments, because the dequeue operation is similar for each implementation.
That is, the elements are in the correct order in the queue.
The implementation only needs to dequeue and remove the element from the head of the list.
Thus, the running time barely differ in milliseconds.

\section{Memory Usage}

\cref{app:memoryusage} summarizes the memory usage of the implementations for the best, average and worst case tests.
The memory usage was the same across implementations, because the algorithms allocate the same number of elements for each test.
Thus, we did not have to calculate the mean and standard deviation for memory usage.

\skippara The implementations' memory usage increase linearly and in relation to the number of elements.
The doubly linked list with and without modification reached similar memory usage.
That is, around 4 Megabytes for 60 000 elements.
And, singly linked list and priority queue implementation had similar memory usage.
That is, around 6 Megabytes for 60 000 elements.
The singly linked list and queue implementation use significantly less memory than the variations of doubly linked list.
For example, for 60 000 elements, the latter implementations use almost 2 Megabytes less memory than the queue based on doubly linked lists.

% Här kan du fördjupa din diskussion och ta ett helhetsgrepp på din undersökning, metodval och resultat.
\section{Discussion}

\subsection{Running Time Analysis}\label{sec:rtanal}
Our time complexity analysis matched with the results we generated from best, average and worst case tests.
That is, the worst case test represents an upper bound limit for the running time of the algorithms, and the best case the lower bound.
However, the most noticeable observation is that the scheduling queue implementation produced almost as low running time as for its lower bound limit.
Thus, the scheduling queue implementation performed the best in terms of time and memory usage.

\skippara The scheduling queue has to traverse through a list, in general, fewer times than the rest of the implementations, because it has a assigned list for each priority.
We can use our complexity analysis, generated data and math notation to express the average running time, where $n$ represents number of elements:
\begin{itemize}
\item \textbf{Singly Linked List and Doubly Linked List} -- In the worst case, these algorithms must traverse $n$ times, and in the best case $\mathcal{O}(1)$.
        Thus, we assume in average that these algorithms must at most traverse $n/2$ times,
    \item \textbf{Doubly Linked List with Modification} -- In the worst case, the algorithm traverses the list $n$ times.
        However, due to its modification, the insertion of new elements takes place in either the head or rear based on an average of first and last element's priority in the queue.
        Thus, we assume in average that this algorithm must at most traverse $n/4$ times.
    \item \textbf{Scheduling Priority} -- This algorithm traverses the list $n$ times in the worst case.
        However, due to its 41 FIFO queues, each separate queue is in general shorter than the previous mentioned queues.
        Thus, we assume in average that this algorithm must at most traverse $n/41$ times.
\end{itemize}

\skippara Based on the assumptions in the list above, we can summarize each implementation's average time complexity in relation to the number of elements as the following:
\begin{equation*}
    \begin{bmatrix*}
        \begin{array}{llll}
            (A) & \text{Singly Linked List} & = & \dfrac{n}{2} \\[3ex]
            (B) & \text{Doubly Linked List} & = & \dfrac{n}{2} \\[3ex]
            (C) & \text{Doubly Linked List with Modification} & = & \dfrac{n}{4} \\[3ex]
            (D) & \text{Scheduling Queue} & = & \dfrac{n}{41}
        \end{array}
    \end{bmatrix*}
    \implies \frac{n}{2} \ge \frac{n}{4} \ge \frac{n}{41}
\end{equation*}

\skippara In average, we noticed that time complexity of (D) is approximately $10\times$ higher than (C), and $20\times$ higher than (A) and (B).
Also, the time complexity of (A) and (B) is roughly $2\times$ higher than (C).
Thus, our running time results from the average case tests yielded similar time complexity.
For example, our running time for $n=60000$ was the following:
\begin{equation*}
    \begin{bmatrix*}
        \begin{array}{llllll}
            (A) & 17695.48 \pm 2\times 201.24 \text{ ms} & \approx 20000 \text{ ms}  & \approx 2\times\text{(C)}\text{ or } 20\times\text{(D)} \\[1ex]
            (B) & 18662.72 \pm 2\times 201.24 \text{ ms} & \approx 20000 \text{ ms}  & \approx 2\times\text{(C)}\text{ or } 20\times\text{(D)} \\[1ex]
            (C) & 9595.70 \pm 2\times 118.06 \text{ ms} & \approx 10000 \text{ ms} & \approx 10\times\text{(D)} \\[1ex]
            (D) & 950.29 \pm 2\times 22.56 \text{ ms} & \approx 1000 \text{ ms} &
        \end{array}
    \end{bmatrix*}
\end{equation*}

\skippara Finally, the dequeue operation for all the algorithms have similar behavior.
That is, all the dequeue operations take $\mathcal{O}(1)$ time.

\subsection{Memory Usage Analysis}
The reason both variations of doubly linked list generated similar memory usage, and higher memory usage than singly linked list and scheduling queue, because these implementations store in total two pointers for each element.
That is, doubly linked lists have a pointer that connects to the previous element, and the second connects to the next element.
Singly linked list and scheduling queue only store one pointer, which refers to the next element in the queue.
Thus, the difference in memory usage is because of an extra pointer allocation.

\subsection{Choice of Methods}
We used a deductive method to analyze each implementation's best and worst case.
That is, we took help of established data structure and complexity theory to determine the best and worst case.
And, assumed the average case's time complexity lies somewhere between the best and worst.

\skippara An inductive method helped us to validate our best and worst case analysis.
Additionally, the average case experiments contributed to a better comprehension of the average time complexities of the algorithms,
That is, we observed patterns in the data from the tests, which resulted in a theoretical analysis and explanation of the algorithms average time complexity, as demonstrated in \cref{sec:rtanal}.
Additionally, the data showed that the average case's time complexity lies indeed between the best (lower bound limit) and worst case (upper bound limit).
Thus, a quantitative experimental study with both inductive and deductive reasoning was a feasible methodology to evaluate algorithms.

% ///////////////////////////////////
% ///////////////////////////////////
%     Conclusions and Future Work
% ///////////////////////////////////
% ///////////////////////////////////

% Kan också kallas Diskussion eller Analys.
% Börja med att diskutera målen och syftet med undersökningen och hur väl du nått dem. Summera de viktigaste slutsatserna/upptäckterna och avsluta med att diskutera hur arbetet skulle kunna fortsättas/utvecklas (speciellt om du inte nått alla delmål)
\chapter{Conclusions and Future Work}

This quantitative experimental study shows that the calculated theoretical space and time complexity of a number of list implementations hold.
The study also shows that the priority queue implementation provides a time complexity better than
a double linked list with a low space complexity as the singly linked list.

\skippara
We applied the scientific method to conduct an experiment with honesty, transparency and rigor.
The experiment helped us to verify and validate our implementations.
We produced a reproducible study and reached the goals to grasp the scientific method.
Finally and hopefully, our analysis and findings can help engineering students to achieve a deeper theoretical and practical comprehension of algorithms and data structures.

% I Bilagor (som inte alltid behöver finnas med) lägger man vid behov utökad information som man inte tar upp/redovisar i detalj i den ordinarie texten.
%
% För den här uppgiften är Bilagorna 1-3 sådana som man kan förvänta sig finnas med i en teknisk rapport om det specifika problem du studerat i den här uppgiften. Bilaga 4 skall innehålla de saker som efterfrågas i ID2206 för att rapporten skall kunna godkännas som labrapport i den kursen.
\appendix
\addappheadtotoc
% Bilaga 1: Källkod för algoritmerna
% Bilaga 2: Källkod för testerna (valideringen)
% Bilaga 3: Källkod för experimenten
% Bilaga 4: Rådata från testerna

\chapter{Requirement Overview}\label{app:A}
% ////////////////////////////////////////////////////////////////////////////////
% ////////////////////////////////////////////////////////////////////////////////
% ////////////////////////////////////////////////////////////////////////////////
% ////////////////////////////////////////////////////////////////////////////////
% //////////////////// CHANGE THIS!!! ////////////////////////////////////////////
% ////////////////////////////////////////////////////////////////////////////////
% ////////////////////////////////////////////////////////////////////////////////
% ////////////////////////////////////////////////////////////////////////////////
% ////////////////////////////////////////////////////////////////////////////////

In \cite{web:requirementoverview}, the author describes that a requirement analysis is a summary of all the requirement the researcher can find.
The author clearly states that this document is \emph{not} about how one should implement something to achieve a specific requirement.
On the contrary, it should only cover the meaning of the requirement.
Thus, we need to set up requirements that describes how to pass the task about the scientific method, specifically experimental quantitative method, as shown in \cref{tab:requirement}.

{\footnotesize
    \begin{longtable}{ |P{2cm}||P{1.7cm}|P{2.2cm}|P{4.3cm}|P{2.3cm}| }
        \caption{Requirement analysis about the scientific method} \label{tab:requirement}\\
        \hline
        Requirement number & Requirement type & Name or source & Clarified description of the requirement, followed by what should be fulfilled& Fulfilled or not fulfilled or partly fulfilled\\
        \hline
        1 & \textbf{Must} mandatory task & Purpose \cite{A3Experi4:online} & Ask good questions and identify the purpose. That is, why is it necessary to conduct an experimental evaluation of algorithms, and what is the application of it. The specific task description is described in \cite{Uppgiftl9:online}. & \\
        \hline
        2 & \textbf{Must} mandatory task & Prestudy \cite{A3Experi4:online} & Demonstrate an understanding about the task and field of study. Also, identify which parameters to use, how these can depend on and vary from each other & \\
        \hline
        3 & \textbf{Must} mandatory task & Methods \cite{A3Experi4:online} & Identify which scientific method(s) to use. For example, quantitative, qualitative, deductive and/or inductive method & \\
        \hline
        4 & \textbf{Must} mandatory task & Experimental Plan \cite{A3Experi4:online} & Identify experiments to conduct. Describe why these are relevant. Examine metrics to measure and elaborate on why these are relevant to this study. & \\
        \hline
        5 & \textbf{Must} mandatory task & Experimental Setup \cite{A3Experi4:online} & Describe in details the resources needed. Identify and examine the influence of error sources, both external and internal ones. Set up an implementation, verification and validation plan. & \\
        \hline
        5 & \textbf{Must} mandatory task & Goals \cite{A3Experi4:online} & Demonstrate how to determine when a goal is reached and an experiment is completed. & \\
        \hline
        6 & \textbf{Must} mandatory task & Communication Part \RN{1} \cite{A3Experi4:online} & Communicate and summarize the discussions of requirement 1-5 (\cref{app:A}) in a document and hand it in to the mentor/supervisor & \\
        \hline
        7 & \textbf{Must} mandatory task & Experimental Execution \cite{A3Experi4:online, Uppgiftl9:online} & Follow the discussed requirements 1-5, or only 6, to conduct the experiments on a real system. And, regularly document the findings with honesty and transparency. & \\
        \hline
        8 & \textbf{Must} mandatory task & Communication Part \RN{2} \cite{A3Experi7:online} & Summarize the entire work and its requirements, that is 1-7, in a smaller version of a technical report. Use the IMRAD-structure (Introduction, Method, Results, and Discussion). It is a common communication structure in scientific reports. & \\
        \hline
\end{longtable}}

% \begin{figure}[ht]
%     \begin{center}
%         And here is a figure
%         \caption{\small{Several statements describing the same resource.}}\label{RDF_4}
%     \end{center}
% \end{figure}

% that we refer to here: \ref{RDF_4}

\chapter{How to Run Experiment}\label{app:howto}
\section{Run Experiments on Host Machine}
\textbf{Requirements}:
\begin{itemize}
    \item make (required)
    \item gcc (required)
    \item python (optional, but required to run correctness test)
    \item valgrind (optional, but required to run memory test)
\end{itemize}

\skippara \textbf{Run the entire experiment:}
\begin{lstlisting}[basicstyle=\ttfamily\normal, frame=single]
$ ./RUN_TESTS.sh
\end{lstlisting}
The script runs a correctness, running time and memory test, respectively.
Correctness test prints out results in terminal.
Running time test stores the results in directory \texttt{./data\_running\_time}, and runs 50 iterations.
Memory test stores results in the directory \texttt{./data\_valgrind}.

\skippara \textbf{Run separate experiments:}
\skippara Correctness test:
\begin{lstlisting}[basicstyle=\ttfamily\normal, frame=single]
$ make
$ ./run_correctness.sh <NUMBER_OF_ELEMENTS>
\end{lstlisting}

\skippara Running time test (best, average and worst case):
\begin{lstlisting}[basicstyle=\ttfamily\normal, frame=single]
$ make
$ ./run_running_time.sh <DATA_DIR> <ITERATIONS>
\end{lstlisting}

\skippara Memory test:
\begin{lstlisting}[basicstyle=\ttfamily\normal, frame=single]
$ make
$ ./run_valgrind.sh <DATA_DIR>
\end{lstlisting}

\section{Run Experiments with Docker on Host Machine}
\textbf{Requirements}
\begin{itemize}
    \item Docker (required)
\end{itemize}

\skippara \textbf{1) Create an image:}
\begin{lstlisting}[basicstyle=\ttfamily\normal, frame=single]
$ docker build -t <IMAGE_NAME> .
\end{lstlisting}

\skippara Run entire experiment in container and interactive mode with bash:
\begin{lstlisting}[basicstyle=\ttfamily\normal, frame=single]
$ docker run -it --entrypoint bash <IMAGE_NAME>
\end{lstlisting}


\skippara Run entire experiment in container to store data on host machine:
\begin{lstlisting}[basicstyle=\ttfamily\normal, frame=single]
$ docker run \
    -v <DIRECTORY_NAME>:/usr/src/experiment/data_running_time \
    -v <DIRECTORY_NAME>:/usr/src/experiment/data_valgrind \
    <IMAGE_NAME>
\end{lstlisting}

\skippara Run entire experiment in container to store data on host machine in the background:
\begin{lstlisting}[basicstyle=\ttfamily\normal, frame=single]
$ docker run -d \
    -v <DIRECTORY_NAME>:/usr/src/experiment/data_running_time \
    -v <DIRECTORY_NAME>:/usr/src/experiment/data_valgrind \
    <IMAGE_NAME>
\end{lstlisting}

\skippara Run separate experiment in container to store data on host machine:
\begin{lstlisting}[basicstyle=\ttfamily\normal, frame=single]
$ docker run --entrypoint test_correctness.sh <IMAGE_NAME>
\end{lstlisting}
\begin{lstlisting}[basicstyle=\ttfamily\normal, frame=single]
$ docker run --entrypoint test_running_time.sh \
    -v <DIRECTORY_NAME>:/usr/src/experiment/data_running_time \
    <IMAGE_NAME>
\end{lstlisting}
\begin{lstlisting}[basicstyle=\ttfamily\normal, frame=single]
$ docker run --entrypoint test_valgrind.sh \
    -v <DIRECTORY_NAME>:/usr/src/experiment/data_valgrind \
    <IMAGE_NAME>
\end{lstlisting}
% 1) Create an image:
% ```bash
% ```
% ```
% ```
% ```
% ```
% ```bash
% ```bash
% ```

\chapter{Results -- Singly Linked List}\label{app:singly}

\begin{figure}[h!]
    \begin{adjustbox}{width=1\textwidth, center}
        \renewcommand*\arraystretch{1.5}
        \begin{tikzpicture}
            \begin{axis}[
                title={},
                legend style={font=\scriptsize},
                x label style = {text height = 0.7cm},
                xlabel={Number of elements},
                ylabel={Seconds},
                xmin=10000, xmax=60000,
                ymin=0, ymax=42,
                xtick={10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 55000, 60000},
                ytick={0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42},
                legend pos=south east,
                ymajorgrids=true,
                grid style=dashed,
                height=11cm,
                width=20cm,
                /pgf/number format/.cd,
                1000 sep={}
                ]

                \addplot [style=thick, color=green, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../data_all_latex/singly_linked_list_best_enqueue.dat};

                \addplot [style=thick, color=blue, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../data_all_latex/singly_linked_list_avg_enqueue.dat};

                \addplot [style=thick, color=red, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../data_all_latex/singly_linked_list_worst_enqueue.dat};

                \legend{Best, Average, Worst}

            \end{axis}
        \end{tikzpicture}
    \end{adjustbox}
    \caption{Running Time Enqueue Results -- Singly Linked List}
    \label{graph:Esingly}
\end{figure}

\begin{table}[ht!]
\caption{Best Case Enqueue -- Singly Linked List }
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000*2},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/singly_linked_list_best_enqueue.dat}
\end{table}

\begin{table}[ht!]
\caption{Average Case Enqueue -- Singly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/singly_linked_list_avg_enqueue.dat}
\end{table}

\begin{table}[ht!]
\caption{Worst Case Enqueue -- Singly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/singly_linked_list_worst_enqueue.dat}
\end{table}

\begin{figure}[h!]
    \begin{adjustbox}{width=1\textwidth, center}
        \renewcommand*\arraystretch{1.5}
        \begin{tikzpicture}
            \begin{axis}[
                title={},
                legend style={font=\scriptsize},
                x label style = {text height = 0.7cm},
                xlabel={Number of elements},
                ylabel={Milliseconds},
                xmin=10000, xmax=60000,
                ymin=0, ymax=20,
                xtick={10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 55000, 60000},
                ytick={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20},
                legend pos=south east,
                ymajorgrids=true,
                grid style=dashed,
                height=11cm,
                width=20cm,
                /pgf/number format/.cd,
                1000 sep={}
                ]

                \addplot [style=thick, color=green, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../data_all_latex/singly_linked_list_best_dequeue.dat};

                \addplot [style=thick, color=blue, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../data_all_latex/singly_linked_list_avg_dequeue.dat};

                \addplot [style=thick, color=red, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../data_all_latex/singly_linked_list_worst_dequeue.dat};


                \legend{Best, Average, Worst}

            \end{axis}
        \end{tikzpicture}
    \end{adjustbox}
    \caption{Running Time Dequeue Results -- Singly Linked List}
    \label{}
\end{figure}

\clearpage

\begin{table}[ht!]
\caption{Best Case Dequeue -- Singly Linked List }
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/singly_linked_list_best_dequeue.dat}
\end{table}

\begin{table}[ht!]
\caption{Average Case Dequeue -- Singly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/singly_linked_list_avg_dequeue.dat}
\end{table}

\begin{table}[ht!]
\caption{Worst Case Dequeue -- Singly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/singly_linked_list_worst_dequeue.dat}
\end{table}



\chapter{Results -- Doubly Linked List}\label{app:doubly}

\begin{figure}[h!]
    \begin{adjustbox}{width=1\textwidth, center}
        \renewcommand*\arraystretch{1.5}
        \begin{tikzpicture}
            \begin{axis}[
                title={},
                legend style={font=\scriptsize},
                x label style = {text height = 0.7cm},
                xlabel={Number of elements},
                ylabel={Seconds},
                xmin=10000, xmax=60000,
                ymin=0, ymax=42,
                xtick={10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 55000, 60000},
                ytick={0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42},
                legend pos=south east,
                ymajorgrids=true,
                grid style=dashed,
                height=11cm,
                width=20cm,
                /pgf/number format/.cd,
                1000 sep={}
                ]

                \addplot [style=thick, color=green, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../data_all_latex/doubly_linked_list_best_enqueue.dat};

                \addplot [style=thick, color=blue, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../data_all_latex/doubly_linked_list_avg_enqueue.dat};

                \addplot [style=thick, color=red, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../data_all_latex/doubly_linked_list_worst_enqueue.dat};

                \legend{Best, Average, Worst}

            \end{axis}
        \end{tikzpicture}
    \end{adjustbox}
    \caption{Running Time Enqueue Results -- Doubly Linked List}
    \label{graph:Edoubly}
\end{figure}

\begin{table}[ht!]
\caption{Best Case Enqueue -- Doubly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/doubly_linked_list_best_enqueue.dat}
\end{table}

\begin{table}[ht!]
\caption{Average Case Enqueue -- Doubly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/doubly_linked_list_avg_enqueue.dat}
\end{table}

\begin{table}[ht!]
\caption{Worst Case Enqueue -- Doubly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    1000 sep={},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/doubly_linked_list_worst_enqueue.dat}
\end{table}

\begin{figure}[h!]
    \begin{adjustbox}{width=1\textwidth, center}
        \renewcommand*\arraystretch{1.5}
        \begin{tikzpicture}
            \begin{axis}[
                title={},
                legend style={font=\scriptsize},
                x label style = {text height = 0.7cm},
                xlabel={Number of elements},
                ylabel={Milliseconds},
                xmin=10000, xmax=60000,
                ymin=0, ymax=20,
                xtick={10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 55000, 60000},
                ytick={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20},
                legend pos=south east,
                ymajorgrids=true,
                grid style=dashed,
                height=11cm,
                width=20cm,
                /pgf/number format/.cd,
                1000 sep={}
                ]

                \addplot [style=thick, color=green, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../data_all_latex/doubly_linked_list_best_dequeue.dat};

                \addplot [style=thick, color=blue, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../data_all_latex/doubly_linked_list_avg_dequeue.dat};

                \addplot [style=thick, color=red, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../data_all_latex/doubly_linked_list_worst_dequeue.dat};


                \legend{Best, Average, Worst}

            \end{axis}
        \end{tikzpicture}
    \end{adjustbox}
    \caption{Running Time Dequeue Results -- Doubly Linked List}
    \label{}
\end{figure}
\clearpage

\begin{table}[ht!]
\caption{Best Case Dequeue -- Doubly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/doubly_linked_list_best_dequeue.dat}
\end{table}

\begin{table}[ht!]
\caption{Average Case Dequeue -- Doubly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/doubly_linked_list_avg_dequeue.dat}
\end{table}

\begin{table}[ht!]
\caption{Worst Case Dequeue -- Doubly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/doubly_linked_list_worst_dequeue.dat}
\end{table}

\chapter{Results -- Doubly Linked List with Modification}\label{app:doublyavg}

\begin{figure}[h!]
    \begin{adjustbox}{width=1\textwidth, center}
        \renewcommand*\arraystretch{1.5}
        \begin{tikzpicture}
            \begin{axis}[
                title={},
                legend style={font=\scriptsize},
                x label style = {text height = 0.7cm},
                xlabel={Number of elements},
                ylabel={Seconds},
                xmin=10000, xmax=60000,
                ymin=0, ymax=42,
                xtick={10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 55000, 60000},
                ytick={0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42},
                legend pos=south east,
                ymajorgrids=true,
                grid style=dashed,
                height=11cm,
                width=20cm,
                /pgf/number format/.cd,
                1000 sep={}
                ]

                \addplot [style=thick, color=green, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../data_all_latex/doubly_linked_list_avg_best_enqueue.dat};

                \addplot [style=thick, color=blue, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../data_all_latex/doubly_linked_list_avg_avg_enqueue.dat};

                \addplot [style=thick, color=red, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../data_all_latex/doubly_linked_list_avg_worst_enqueue.dat};

                \legend{Best, Average, Worst}

            \end{axis}
        \end{tikzpicture}
    \end{adjustbox}
    \caption{Running Time Enqueue Results -- Doubly Linked List with Modification}
    \label{graph:Eavg}
\end{figure}

\begin{table}[ht!]
\caption{Best Case Enqueue -- Doubly Linked List with Modification}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/doubly_linked_list_avg_best_enqueue.dat}
\end{table}


\begin{table}[ht!]
\caption{Average Case Enqueue -- Doubly Linked List with Modification}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/doubly_linked_list_avg_avg_enqueue.dat}
\end{table}

\begin{table}[ht!]
\caption{Worst Case Enqueue -- Doubly Linked List with Modification}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    1000 sep={},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/doubly_linked_list_avg_worst_enqueue.dat}
\end{table}

\begin{figure}[h!]
    \begin{adjustbox}{width=1\textwidth, center}
        \renewcommand*\arraystretch{1.5}
        \begin{tikzpicture}
            \begin{axis}[
                title={},
                legend style={font=\scriptsize},
                x label style = {text height = 0.7cm},
                xlabel={Number of elements},
                ylabel={Milliseconds},
                xmin=10000, xmax=60000,
                ymin=0, ymax=20,
                xtick={10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 55000, 60000},
                ytick={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20},
                legend pos=south east,
                ymajorgrids=true,
                grid style=dashed,
                height=11cm,
                width=20cm,
                /pgf/number format/.cd,
                1000 sep={}
                ]

                \addplot [style=thick, color=green, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000,y expr = \thisrowno{1}*1000]{../data_all_latex/doubly_linked_list_avg_best_dequeue.dat};

                \addplot [style=thick, color=blue, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../data_all_latex/doubly_linked_list_avg_avg_dequeue.dat};

                \addplot [style=thick, color=red, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../data_all_latex/doubly_linked_list_avg_worst_dequeue.dat};


                \legend{Best, Average, Worst}

            \end{axis}
        \end{tikzpicture}
    \end{adjustbox}
    \caption{Running Time Dequeue Results -- Doubly Linked List with Modification}
    \label{}
\end{figure}
\clearpage


\begin{table}[ht!]
\caption{Best Case Dequeue -- Doubly Linked List with Modification}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/doubly_linked_list_avg_best_dequeue.dat}
\end{table}

\begin{table}[ht!]
\caption{Average Case Dequeue -- Doubly Linked List with Modification}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/doubly_linked_list_avg_avg_dequeue.dat}
\end{table}

\begin{table}[ht!]
\caption{Worst Case Dequeue -- Doubly Linked List with Modification}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/doubly_linked_list_avg_worst_dequeue.dat}
\end{table}

\chapter{Results -- Scheduling Queue}\label{app:arraypriority}

\begin{figure}[h!]
    \begin{adjustbox}{width=1\textwidth, center}
        \renewcommand*\arraystretch{1.5}
        \begin{tikzpicture}
            \begin{axis}[
                title={},
                legend style={font=\scriptsize},
                x label style = {text height = 0.7cm},
                xlabel={Number of elements},
                ylabel={Seconds},
                xmin=10000, xmax=60000,
                ymin=0, ymax=42,
                xtick={10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 55000, 60000},
                ytick={0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42},
                legend pos=south east,
                ymajorgrids=true,
                grid style=dashed,
                height=11cm,
                width=20cm,
                /pgf/number format/.cd,
                1000 sep={}
                ]

                \addplot [style=thick, color=green, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../data_all_latex/array_priority_best_enqueue.dat};

                \addplot [style=thick, color=blue, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../data_all_latex/array_priority_avg_enqueue.dat};

                \addplot [style=thick, color=red, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../data_all_latex/array_priority_worst_enqueue.dat};


                \legend{Best, Average, Worst}

            \end{axis}
        \end{tikzpicture}
    \end{adjustbox}
    \caption{Running Time Enqueue Results -- Scheduling Queue}
    \label{graph:Earray}
\end{figure}
\begin{table}[ht!]
\caption{Best Case Enqueue -- Scheduling Queue}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/array_priority_best_enqueue.dat}
\end{table}




\begin{table}[ht!]
\caption{Average Case Enqueue -- Scheduling Queue}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/array_priority_avg_enqueue.dat}
\end{table}




\begin{table}[ht!]
\caption{Worst Case Enqueue -- Scheduling Queue}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/array_priority_worst_enqueue.dat}
\end{table}


\begin{figure}[h!]
    \begin{adjustbox}{width=1\textwidth, center}
        \renewcommand*\arraystretch{1.5}
        \begin{tikzpicture}
            \begin{axis}[
                title={},
                legend style={font=\scriptsize},
                x label style = {text height = 0.7cm},
                xlabel={Number of elements},
                ylabel={Milliseconds},
                xmin=10000, xmax=60000,
                ymin=0, ymax=20,
                xtick={10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 55000, 60000},
                ytick={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20},
                legend pos=south east,
                ymajorgrids=true,
                grid style=dashed,
                height=11cm,
                width=20cm,
                /pgf/number format/.cd,
                1000 sep={}
                ]

                \addplot [style=thick, color=green, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../data_all_latex/array_priority_best_dequeue.dat};

                \addplot [style=thick, color=blue, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../data_all_latex/array_priority_avg_dequeue.dat};

                \addplot [style=thick, color=red, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../data_all_latex/array_priority_worst_dequeue.dat};


                \legend{Best, Average, Worst}

            \end{axis}
        \end{tikzpicture}
    \end{adjustbox}
    \caption{Running Time Dequeue Results -- Scheduling Queue}
    \label{}
\end{figure}

\clearpage

\begin{table}[ht!]
\caption{Best Case Dequeue -- Scheduling Queue}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/array_priority_best_dequeue.dat}
\end{table}




\begin{table}[ht!]
\caption{Average Case Dequeue -- Scheduling Queue}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/array_priority_avg_dequeue.dat}
\end{table}




\begin{table}[ht!]
\caption{Worst Case Dequeue -- Scheduling Queue}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/array_priority_worst_dequeue.dat}
\end{table}

\chapter{Results -- Memory Usage}\label{app:memoryusage}

The best, worst, average case tests are included in the total memory usage for each implementation.
Thus, the higher memory usage.

\begin{figure}[h!]
    \begin{adjustbox}{width=1\textwidth, center}
        \renewcommand*\arraystretch{1.5}
        \begin{tikzpicture}
            \begin{axis}[
                title={},
                legend style={font=\scriptsize},
                x label style = {text height = 0.7cm},
                xlabel={Number of elements},
                ylabel={Bytes},
                xmin=10000, xmax=60000,
                ymin=0, ymax=6000000,
                xtick={10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 55000, 60000},
                ytick={0, 500000, 1000000, 1500000, 2000000, 2500000, 3000000, 3500000, 4000000, 4500000, 5000000, 5500000, 6000000},
                legend pos=south east,
                ymajorgrids=true,
                grid style=dashed,
                height=11cm,
                width=20cm,
                /pgf/number format/.cd,
                1000 sep={}
                ]

                \addplot [style=thick, color=green, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[]{../data_all_latex/singly_linked_list_memory.dat};

                \addplot [style=thick, color=blue, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[]{../data_all_latex/doubly_linked_list_memory.dat};

                \addplot [color=red, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[]{../data_all_latex/doubly_linked_list_avg_memory.dat};

                \addplot [color=black, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[]{../data_all_latex/array_priority_memory.dat};

                \legend{Singly Linked List, Doubly Linked List, Doubly Linked List with modification, Scheduling Queue}

            \end{axis}
        \end{tikzpicture}
    \end{adjustbox}
    \caption{Memory Usage Results of the All Queues}
    \label{graph:memoryusage}
\end{figure}

\begin{table}[ht!]
\caption{Memory Usage -- Singly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Memory Usage in Megabytes},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1/1000000},
    1000 sep={},
    /pgf/number format/precision=2,
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/singly_linked_list_memory.dat}
\end{table}

\begin{table}[ht!]
\caption{Memory Usage -- Doubly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Memory Usage in Megabytes},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1/1000000},
    1000 sep={},
    /pgf/number format/precision=2,
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/doubly_linked_list_memory.dat}
\end{table}

\begin{table}[ht!]
\caption{Memory Usage -- Doubly Linked List with Modification}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Memory Usage in Megabytes},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1/1000000},
    1000 sep={},
    /pgf/number format/precision=2,
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/doubly_linked_list_avg_memory.dat}
\end{table}

\begin{table}[ht!]
\caption{Memory Usage -- Scheduling Queue}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Memory Usage in Megabytes},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1/1000000},
    1000 sep={},
    /pgf/number format/precision=2,
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../data_all_latex/array_priority_memory.dat}
\end{table}

\chapter{Code -- \texttt{main.c}}
\lstinputlisting[language=c]{../src/main.c}

\chapter{Code -- \texttt{queue.c}}
\lstinputlisting[language=c]{../src/queues.c}

\chapter{Code -- \texttt{queue.h}}
\lstinputlisting[language=c]{../src/queues.h}

\chapter{Code -- \texttt{RUN\_TESTS.sh}}
\lstinputlisting[language=bash]{../RUN_TESTS.sh}
\chapter{Code -- \texttt{test\_correctness.sh}}
\lstinputlisting[language=bash]{../test_correctness.sh}
\chapter{Code -- \texttt{test\_running\_time.sh}}
\lstinputlisting[language=bash]{../test_running_time.sh}
\chapter{Code -- \texttt{test\_valgrind.sh}}
\lstinputlisting[language=bash]{../test_valgrind.sh}
\chapter{Code -- \texttt{generate\_correctness\_in\_out\_file.py}}
\lstinputlisting[language=python]{../src/generate_correctness_in_out_file.py}

\clearpage
% Här listar du dina referenser. De skall täcka in alla relevanta delar  i din bakgrund, vara väl utvalda (dvs. hålla för källkritik).
%
% I den här rapporten använder du ISO690 numerisk variant för referenserna.
%
% Har man ett bra verktyg som man skriver i/hantera referenserna i så kan referenslistan automatgenereras. Det gör det också lättare att uppdatera referenslistan utan att behöva gå igenom varje referens i texten manuellt. Dessutom får man bara med källor som man refererat till minst en gång från texten.
\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,sources}
\end{document}
