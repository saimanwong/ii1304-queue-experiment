\documentclass[a4paper,11pt]{kth-mag}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{lmodern}
\usepackage[latin1]{inputenc}
\usepackage[swedish,english]{babel}
\usepackage{modifications}
\usepackage{mathtools}
\usepackage{pgfplotstable, booktabs}
\usepackage{color, colortbl}
\usepackage{adjustbox}
\usepackage{graphicx} % Required to insert images
\usepackage[colorlinks=true, citecolor=magenta, linkcolor=magenta]{hyperref}
\usepackage[nameinlink, capitalise]{cleveref}
\newcommand{\RN}[1]{%
      \textup{\uppercase\expandafter{\romannumeral#1}}%
  }
\usepackage{longtable}
\newcommand\fnurl[2]{%
    \href{#1}{#2}\footnote{\url{#1}}%
}
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\newcommand\floor[1]{\lfloor#1\rfloor}

\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

% För formateringen av en rapport/artikel finns ofta färdiga mallar. Publicerar man t.ex. en artikel på en konferens eller i en tidskrift finns mallar/anvisningar som beskriver vilka typsnitt, storlekar, radavstånd, marginaler paragrafnumrering etc. som skall användas.
% Ofta beskrivs också hur lång texten får vara i antal ord och antal sidor.
% För den här uppgiften skall texten ligga mellan 7 och 12 sidor oräknat försättsblad, Abstract, sammanfattning, referenslista och bilagor.

% Den här rapportmallen beskriver vad man kan förvänta sig finna i en teknisk rapport som baseras på någon form av undersökning/utredning. De rubriker/stycken som är beskrivna är de som återfinns i de allra flesta rapporter. För längre rapporter delar man ofta upp rapporten i flera stycken med egna rubriker. T.ex. kanske man beskriver flera olika experiment och experimentuppställningar.

% I rapporten kan och bör du återanvända delar av det du skrivit i din projektplanering.

% Försättssida: Titeln skall vara deskriptiv/informativ. Sätts i Arial 14 punkter fet stil (KTH titel)

% Försättssida: Här anger man namn på alla författare, titlar och kontaktinformation
\title{Priority Queues Experiment}
\subtitle{December 3, 2017}
\foreigntitle{Lorem ipsum dolor sit amet, sed diam nonummy nibh eui mod tincidunt ut laoreet dol}
\author{Wong, Sai Man\\ Tigerstr\"{o}m, Gabriel}
\date{November 2016}
\blurb{}
\trita{}
\newcommand*{\skippara}{\par\vspace{\baselineskip} \noindent}
\begin{document}
\frontmatter
\pagestyle{empty}
\removepagenumbers
\maketitle
\selectlanguage{english}

% Ny sida- startar på högersida: I examensarbetsrapporter på KTH skall det finnas sammanfattning på både svenska och engelska (Abstract). Rubriken sätts i Arial 12 punkter fet stil ( KTH rubrik), brödtexten som  Times New Roman 10 punkter (KTH Brödtext)
\begin{abstract}
This is a skeleton for KTH theses. More documentation
regarding the KTH thesis class file can be found in
the package documentation.

Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Mauris
purus. Fusce tempor. Nulla facilisi. Sed at turpis. Phasellus eu
ipsum. Nam porttitor laoreet nulla. Phasellus massa massa, auctor
rutrum, vehicula ut, porttitor a, massa. Pellentesque fringilla. Duis
nibh risus, venenatis ac, tempor sed, vestibulum at, tellus. Class
aptent taciti sociosqu ad litora torquent per conubia nostra, per
inceptos hymenaeos.
\end{abstract}
\clearpage

% Ny sida, startar på högersida. Sammanfattning och Abstract skall innehålla samma text men på olika språk. Sammanfattningen skall översiktligt beskriva vad rapporten innehåller och de viktigaste resultaten. Den hålls normalt ganska kortfattad (1/4-1/2 A4 sida text. De skrivs på separata sidor.
\begin{foreignabstract}{swedish}
Denna fil ger ett avhandlingsskelett.
Mer information om \LaTeX-mallen finns i
dokumentationen till paketet.

Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Mauris
purus. Fusce tempor. Nulla facilisi. Sed at turpis. Phasellus eu
ipsum. Nam porttitor laoreet nulla. Phasellus massa massa, auctor
rutrum, vehicula ut, porttitor a, massa. Pellentesque fringilla. Duis
nibh risus, venenatis ac, tempor sed, vestibulum at, tellus. Class
aptent taciti sociosqu ad litora torquent per conubia nostra, per
inceptos hymenaeos.
\end{foreignabstract}
\clearpage

% Om man har ett bra verktyg som man skriver sin rapport i och man använder väldefinierade paragraf/stilmallar så kan innehållsförteckningen oftast automatgenereras
{
    \hypersetup{linkcolor=black}
    \tableofcontents*
}
\mainmatter
\pagestyle{newchap}

% ///////////////////////////////////
% ///////////////////////////////////
%           Introduction
% ///////////////////////////////////
% ///////////////////////////////////

% Huvudrubriker sätts i Arial 12 punkter fet stil autonumrerad (KTH nRubrik 1). Här introducerar man problemomådet. Här skall finnas en bakgrund till projektet, de problem man adresserar/undersöker och syftet med arbetet.De olika underkapitlen/styckena till introduktionen  förtydligar det du skriver här. Här förväntar man sig hitta ett antal noga utvalda hög-kvalitativa referenser.
\chapter{Introduction}
A researcher plan in advance to conduct a successful and credible scientific work.
However, students and engineers occasionally approach the planning phase in a careless manner.
As a result, researchers waste time to redo the changes due to poor design and execution.
Students and engineers lack a deeper knowledge of the scientific method to contribute with quality work.
That is, science emphasizes the importance of theoretical knowledge and its application in practice.
Thus, in our study, we used the scientific method to evaluate algorithms with a rigorous, honest and transparent method.

% Underrubriker (första nivån) sätts i Arial 12 punkter fet stil autonumrerad (KTH  nRubrik 2). (Har man ytterligare undernivåer sätter man rubrikerna för nästa nivå  med (KTH nRubrik 3)) Man försöker ofta begäränsa sig till tre nivåer på rubriker och man har i princip aldrig fler än 4 nivåer på rubriker.
%I stycket om bakgrund (som ibland kallas ”Related work” på engelska) förväntar man sig hitta en gedigen bakgrundsbeskrivning till problemområdet i stort och till det specifika problem som studeras i rapporten. Den skall innehålla/baseras på en litteraturstudie. Det behöver väl knappast påpekas att den bör innehålla utvalda, högkvalitativa referenser.
\section{Background}
A data structure represent a model to store data with a methodical approach \cite{deshpande2004c}.
Software engineers use queues in software development to manage arbitrary entities in a first-in-first-out (FIFO) order.
For example, developers use a queue to develop a memory buffer or scheduling in an operating system.

\skippara Higher level programming languages often provide a standardized library with finished implementations, such as a queue.
Software developers use these implementations frequently, and sometimes take the underlying architecture for granted.
Thus, an inexperienced developer possess a limited knowledge of the theory and technical aspects of the used implementations.

\skippara Developers use the data structure, or model, linked list to store data linearly.
The simple linked list consists of entities. 
An entity stores data and includes a connection to the next entity in the list. 
Computer scientist and developers refer the entity as a node or an element, and the connection as a pointer.
That is, an element stores data and consists of a pointer to the next element in the list.
Thus, developers frequently use linked list implementations to store and manage data linearly, for example, in a queue implementation.  


% Här beskriver du problemområdet och problemet i detalj. Beskriv också varför det är värdefullt att undersöka problemet. Försök formulera din problemställning så klart och koncist som möjligt – gärna i en mening!
\section{Problem}\label{sec:problem}
An engineer must learn the skill to apply the scientific method in practice.
That is, to later on possess the ability to contribute with further development and exploration within the scientific community.
Also, a software engineer needs to grasp the basics of features in an API\footnote{API -- Application Programming Interface}-library.
However, developers sometimes use these library features in projects, and take these algorithms for granted to behave in a specific manner.
Thus, we applied the scientific method rigorously to evaluate algorithms in depth, both in theory and practice.

\skippara Our task was to evaluate four variations of a list-based data structure to represent a queue \cite{Uppgiftl9:online}.
Each element compromises of a number to represent its priority in the queue.
For clarification, an element with a low number represents higher priority, because the element lies closer to the time and ready for execution.
We implemented the queues in the low-level programming language \texttt{C}, and the following list presents the implementation specifications:
\begin{enumerate}
    \item \textbf{Singly linked list} -- Insertion of new elements takes place in the head.
    \item \textbf{Doubly linked list} -- Insertion of new elements takes place in the rear.
        \item \textbf{Doubly linked list} -- Insertion of new elements takes place based on the mean of the first and last element's priority.
        \begin{itemize}
            \item In the head -- The new element's priority is higher than the mean, that is, \\numerical value $<$ mean value.
            \item In the rear -- The new element's priority is lower than the mean, that is,\\numerical value $\ge$ mean value.
        \end{itemize}
    \item \textbf{Scheduling queue} -- The queue consists of an FIFO-queue for each priority in the $[0,40]$ interval.
\end{enumerate}

\skippara 
Computer scientists evaluate algorithms in terms of space and time, such as execution time and memory usage.
That is, we gather a large quantity of these metric to determine best, average and worst cases.
Thus, we asked ourselves: ``Do these queues achieve similar performance, or does the performance vary depending on the circumstance?''


\clearpage
% Om detta är en studie där syftet är att undersöka en hypotes (alla projekt är inte hypotesprövande) så beskriver du/formulerar du hypotesen här. Lämpligt är också att beskriva hur/varför/på vilka grunder du formulerat hypotesen. Är det inte ett hypotesprövande projekt så tar du bort rubriken.
\section{Hypothesis}
A queue either enqueues or dequeues elements with an FIFO policy.
Because of the FIFO policy, we assumed with a correct implementation and theory, the dequeue-operation take $\mathcal{O}(1)$ time.
However, the enqueue-operation becomes more sensitive to an element's priority, because the algorithm insert each element in the correct spot in the queue.
Thus, the implementations perform differently because of priority distribution.
For example, the implementation reaches $\mathcal{O}(n)$ time if the algorithm traverses through the entire list to enqueue an element.

\skippara The following list describes our hypotheses:
\begin{itemize}
    \item The dequeue-operation for all the queues takes $\mathcal{O}(1)$ time.
    \item The enqueue-operation for all the queues takes $\mathcal{O}(n)$ time.
\end{itemize}

% Beskriv varför projektet genomförs.
\section{Purpose}
Our purpose was to raise awareness of the features in API-libraries with the scientific method, which developers and engineers often take for granted.
Thus, we conducted experiments to achieve a deeper knowledge to apply the scientific method, and to evaluate four versions of a queue implementation.
Consequently, we wanted to contribute with a study students and engineers can learn from and further develop.

% Beskriv de förväntade resultat- och effektmålen av undersökningen. Beskriv alla mål du satt upp även om de inte nåddes!
\section{Goal}
The bigger goal was to attain deeper knowledge of the scientific method, and apply the method to evaluate four queue-implementations.
However, the following list demonstrates the sub-goals:
\begin{itemize}
    \item Apply scientific method to plan, design, experiment, document, analyze and present the findings.
    \item Grasp the importance of scientific method.
    \item Conduct a reproducible study.
    \item Attain the ability to present, analyze and draw conclusions from experiments, both in theory and practice.
    \item Implement queues correctly, that is, verify its behavior and validate the data.
    \item Create tests to generate the execution time and memory usage from the algorithms.
\end{itemize}

% Beskriv vem och på vilket sätt man kan ha nytta av utredningen. Beskriv etiska och hållbar utvecklingsrelaterade frågor kopplade till utredningen.
\section{Social Benefit, Ethics and Sustainable Development}
Our study influence students and engineers to apply the scientific method more with a more serious approach.
Also, the study facilitate the process for software engineers to choose an implementation of a queue, which fits their specific purpose.
Finally, we delve into the foundations of algorithms, data structure and complexity theory.
Thus, our work help students and engineers to acquire a deeper comprehension of computer science.

\skippara Within science, a researcher undertake a moral responsibility to conduct a reproducible work with honesty and transparency.
However, sometimes scientists encounter difficult circumstances, which limits their ability to produce a reproducible work.
For example, due to economical and practical reasons, such as expensive hardware.
We documented each step and presented findings with rigor, honesty and transparency.
That is, we encourage students to reproduce our findings.

\skippara We conducted the experiment on a virtual machine on Microsoft's cloud platform.
Thus, we used the exact quantity of resources needed to conduct the experiments.
That is, we avoided to waste unnecessary electricity due to, for example, system idle.



% I större, mer omfattande rapporter med flera stycken lägger man ibland till en översikt Disposition (Overview) som beskrivar vad läsaren kommer att hitta i de olika styckena. Syftet är att hjälpa läsaren få en översikt över rapporten så han/hon kan hitta snabbt i den.
\section{Outline}



% ///////////////////////////////////
% ///////////////////////////////////
%       Method
% ///////////////////////////////////
% ///////////////////////////////////

% I metoelen beskriver du den vetenskapliga metod du baserat ditt projekt på.
%
% Vilka relevanta metoder finns? Vilka har du övervägt att använda? Varför valde du den/de metoder du använt?
%  Beskriv kort den metod du använt och hur du applicerat den - dvs. vilken data du samlar in, hur du gör det och varför. Beskriv också tillförlitligheten hos data du samlar in. Går experimenten att upprepa? Finns etiska eller HU aspekter på ditt arbete.
\chapter{Method}

\section{Inductive and Deductive Method}
Scientists apply an inductive method when they try to reach practical conclusions from observations or data \cite{Omexperi69:online}.
That is, in sequential order to 1) collect data, 2) detect pattern in it, 3) set up a hypothesis and 4) try to explain the findings with established theory to reach 5) a conclusion \cite{web:induction}.
It is sometimes informally called a bottom-up approach due to its style to start with observations.
Software engineers frequently apply this method to observe algorithms and a system's behavior.
For example, a developer with specific an input can generate output from an algorithm to create an understanding of how it works.

\skippara With the deductive method, also called top-down approach, scientists try to reach logical conclusions from theory.
For example, mathematicians use a deductive method to try to explain something unknown with help of well-established theory (axioms and theorems).
This also applies to researchers within computer science.
That is, they use mathematical notations to represent theoretical models in, for example, algorithm analysis and complexity theory.
Thus, researchers use these methods for different purposes, and they sometimes combine them to reach both a logical and practical conclusion.

\section{Quantitative and Qualitative Method}

Researches apply a quantitative method in studies that rely on measurable data in large quantities to explain findings \cite{haakansson2013portal}.
That is, the metrics in a quantitative study are measurable, such as time, temperature and age.
These studies frequently apply statistical analysis to summarize the data in tables and graphs with error margins.
For example, scientists use a quantitative method to try to predict a nation's growth based on the birth and death rate over a longer period.

\skippara In contrast, a qualitative method relies on data of quality to interpret the results \cite{merriam2009qualitative}.
Scientists use this method in studies when the data significantly more difficult to quantify, such as opinions, thoughts and happiness.
The data are usually collected from other people in form of interviews and surveys.
Thus, psychologists frequently implement a qualitative method to try to understand people's behavior.

% Beskriv hur du samlar in data, material och annat underlag för din undersökning? Svara på frågor som: Hur skall undersökningen genomföras? Hur är experimentuppställningen organiserad?
\section{Data Collection}
The most relevant metrics to examine algorithms with are time and space, such as execution time and memory usage.
These metrics are all quantifiable.
In contrast to, for example, interviews and surveys, which are common methods in qualitative studies \cite{Omexperi69:online, haakansson2013portal}.
That is, qualitative studies reaches conclusions from the quality of the data rather quantity.
Thus, this study uses an experimental quantitative method to try to get a deeper insight about queues.

\skippara For each of the four queue-implementations, we tested and generated the execution time for best, average and worst case.
That is, we created input for the queues based on different distributions of the element's priorities.
Besides execution time, we also log the memory usage for each implementation.
Finally, we wrote scripts to execute the tests and logged all the raw data.

% Beskriv metoden för hur du avser analysera insamlad data/material. Beskriv också hur du planerar tolka  data
\section{Data Analysis}
We reasoned with a deductive method to explore the theory within computer science, such as algorithm complexity theory.
That is, we can reach theoretical conclusions from complexity theory about the algorithms.
For example, it is possible to determine an algorithm's performance based solely on theoretical knowledge.
However, the usage of deductive methods can also yield unexpected results when put into practice.
Thus, we generate realistic data from our experiments, and use an inductive method to further analyze it.
That is, to explore if we can notice any observable patters in the data with help of models.

\skippara We used both graphs and tables to visualize the execution time and memory usage
And, ran the experiments multiple times to get the sample mean and standard deviation.
Standard deviation is important because it provides a deeper insight about the results around the sample mean.
Also, it can eventually help us identify the external or internal error sources.
For example, if the standard deviation is relatively high, then we can suspect that something is wrong.





% ///////////////////////////////////
% ///////////////////////////////////
%       System Description
% ///////////////////////////////////
% ///////////////////////////////////

% Ett kapitel om Systembeskrivning / Konstruktion eller i detta fall Experimentuppställning  finns inte med i alla studier men ofta i tekniska rapporter där man konstruerat ett system. Den här delen kan vara ett kapitel/stycke eller flera beroende på hur stort arbete man gjort.

% Här startar man normalt med en beskrivning av det/de system man utvecklat och /eller haft som underlag i studien.
\chapter{System Description}


% Om du utvecklat ett system (som algoritmerna för den här studien) så bör du beskriva vilken/vilka metoder och verktyg du använt för systemutvecklingen. I större undersökningar/arbeten vill man gärna också se en diskussion om olika alternativ och varför man valt de man använt.
\section{System Development Method}
Our implementation produces an executable for each of the four queue-implementations.
It consists of primarily three files, \texttt{main.c} with all the tests, \texttt{queues.h} and \texttt{queues.c} which respectively describes and implements the functionalities.
Thus, we use compile time macros to determine which of the four queue-implementation we create an executable from.

\skippara We used Bash-scripts to automatically run tests and log the results in plain text.
Also, we wrote a Python-script that 1) calculated the sample mean and standard deviation, and 2) summarized it in a specific format so that \LaTeX \  can visualize it in either tables or graphs.
Finally, we also use Valgrind to examine that our implementation allocates and deallocates memory correctly.

\skippara We also added an optional solution to run the entire experiment in a container.
That is, if anyone only wants to run the entire experiment without thinking about the set up process, then the user only need to install Docker and run one command to achieve the results as we did.
It is efficient, because containers shares the same resources as the host operating system.


% Det här är en anpassad rubrik för just den här studien. Här beskriver du (ev. med flera underrubriker) mer i detalj de algoritmer du implementerat, analyserar dem och hur du implementerat dem.
\section{Queue Algorithms}\label{sec:algorithms}
Our task is to implement four different queue-implementation in the programming language \texttt{C}, as described in \cref{sec:problem}.
The following are common operations for a queue:
\begin{itemize}
    \item \textbf{Enqueue} -- enqueues the element in the correct spot in the queue, because it is a priority queue.
    \item \textbf{Dequeue} -- dequeues the element with the highest priority, that is, the first element in the queue.
\end{itemize}

\skippara The only operation that can vary in the queue-implementations is the enqueue-operation, because it must insert the element in the correct position in the queue.
Another common feature is that each element stores at least 1) a unique number identifier of the data type integer, 2) a priority number of the data type double and 3) a pointer to refer to other elements.

\skippara The following sections describe how we implemented the queues.
Additionally, we analyze the time complexity for the enqueue-operation as it varies.
Average cases are difficult to analyze theoretically.
However, best and worst cases are easier to analyze in theory.
Thus, we analyze the best and worst case to try to understand the average case for each implementation's enqueue-operation.

\subsection{Singly Linked List}\label{sec:singly}
This implementation uses a singly linked list to represent a queue.
That is, an element in the queue stores 1) a unique number identifier, 2) a priority and 3) a pointer to the next element in the queue.
This algorithm enqueues new elements from head.
The following list analyzes the enqueue-operation's time complexity:
\begin{itemize}
    \item \textbf{Best Case $\mathcal{O}(1)$} -- This occurs when the enqueue-operation of new elements always takes place in the head.
        That is, the implementation does not have to traverse the list to find the correct spot to insert the new element.
        Instead, it needs to only perform one operation to put the new element in the head.
        Thus, we can reach the best case with a distribution of priorities where the numerical value descends from a higher one.
    \item \textbf{Worst Case $\mathcal{O}(n)$} -- This happens when the implementation must traverse through the entire list, or $n$-times, to insert the new element in the correct place.
        Thus, the implementation reaches the worst case scenario with a distribution of priorities with the same numerical value,
because the queue uses an FIFO approach to manage elements with the same priority.
\end{itemize}

\subsection{Doubly Linked List}
This implementation uses a doubly linked list data structure.
An element stores 1) a unique number identifier, 2) priority, and 3-4) two pointers that connects next and previous element.
In this implementation, the enqueue-operation of new elements takes place in the rear.
The following examines the time complexity of this implementation:
\begin{itemize}
    \item \textbf{Best Case $\mathcal{O}(1)$} -- This implementation reaches the best case when the priority distribution consists of the same number.
        Because, it applies FIFO to manage elements with same priorities.
        Thus, it requires only one operation to insert the new element.
    \item \textbf{Worst Case $\mathcal{O}(n)$} -- This queue reaches the worst case when the priority's numerical value constantly descends from a higher one.
        With such numerical distribution, it has to traverse the list from the rear $n$-times to insert the element correctly.
\end{itemize}

\subsection{Doubly Linked List with Modification}
This queue is similar to the previous section's implementations.
That is, an element stores the same properties as the last one.
However, in this implementation the insertion of new elements takes place in either the head or rear.
It depends on the average of the first and last element in the list.
The following list clearly demonstrates the rules of the modified version:
\begin{itemize}
    \item In the head -- New element has a higher priority than the mean value, that is, \\numerical value $<$ mean value.
    \item In the rear -- New element has a lower or equal priority to the mean value, that is,\\numerical value $\ge$ mean value.
\end{itemize}

\skippara We can also analyze the best and worst case for this implementation.
The following summarizes the analysis:
\begin{itemize}
    \item \textbf{Best Case $\mathcal{O}(1)$} -- For the best case, we can either design the distribution of priorities to only take place in either head or rear.
        For example, let us say that we create a distribution with only the same priority.
        The average will always be the same as the new element's priority.
        Thus, the insertion of new elements always takes place in the rear.
    \item \textbf{Worst Case $\mathcal{O}(n)$} -- To achieve the worst case, we must traverse through the list for each enqueue-operation.
        This is possible if the queue, for example, first enqueues two elements with significantly different priorities.
        One with a high priority, and another with significant lower priority.
        The average will skew towards the lower priority, that is, a notably high numerical value.
        Thus, if the new element always will have a little lower priority than the previous one, then the insertion takes place in the head and traverses $(n-1)$-times to insert new element correctly.
\end{itemize}

\subsection{Scheduling Queue}
This implementation uses a static list with 41 entries of pointers
These entries represent the priority in the [0, 40] interval, and each pointer is connected to an FIFO-queue.
Our implementation of the FIFO-queue is a singly linked list, as described in \cref{sec:singly}
The time complexity for best and worst case is:
\begin{itemize}
    \item \textbf{Best Case $\mathcal{O}(n)$} -- The implementation achieve the best time complexity if the elements are equally distributed in the queue.
        The simplest distribution is to enqueue elements from highest to the lowest priority and start over.
        That is, from priority 0 to 40, and then start over from priority 0.
        However, when the implementation starts over from priority 0, the enqueue operation still has to traverse through the FIFO-queues to insert the new elements correctly.
        For example, if we assume that the elements are distributed equally, we can represent the running time as:
        \begin{equation*}
            1 + \left\floor{\frac{n}{41}\right}
        \end{equation*}
        The one represents the cost to access the priority queue.
        The rest represents the cost to traverse through the list.
    \item \textbf{Worst Case $\mathcal{O}(n)$} -- The worst case is the same as described \cref{sec:singly}.
        That is, the implementation has to traverse $n$-times for a distribution of elements with only the same priority.
        The cost to access the priority queue can influence the running time.
        However, in complexity theory, the cost to access is insignificant.
\end{itemize}


% Testbädd eller Experimentuppställning. Också en rubrik specifik för den här undersökningen – men också vanlig i många undersökningar där man utvärderar ett tekniskt system.

% Här beskriver du mer i detalj din experimentuppställning. Vilken hårdvara, OS har du kört på. Hur har du försökt minimera felkällor (sominverkan av andra användare).
% Beskriv de testfall du använt och implementerat. Argumentera för varför de är rimliga/bra.
\section{Experimental Setup}
We conducted the experiments on a Microsoft Azure virtual machine.
Basically, it is a high-performance virtual private server.
We used this service because we have full control over the environment.
The system consisted of a 64 bit architecture virtual CPU with two cores (Intel(R) Xeon(R) CPU E5-2673 v4 @ 2.30GHz), 8 GB memory and Ubuntu 16.04.3 LTS (Xenial Xerus) operating system.

\subsection{Error Sources} Error sources are also necessary to take into account as these can influence the results of this study.
That is, if we identify error sources early in the planning phase, we can then mitigate unexpected behaviors and results.
Every software and computational research depend heavily on the underlying system, both hardware and software.
Assume that the implementation is correct, the results depend on memory and CPU to produce accurate output, but also the operating system.
Thus, we run the experiments multiple times and calculate statistical features, such as mean value and standard deviation.
Standard deviation is relevant, because we can then identify how the execution time vary around the mean.
For example, a large standard deviation indicates, for example, that another process irregularly consume a large amount of resources.

\skippara Another error source is poor design and implementation of models.
Thus, it important to grasp and follow scientific methodology rigorously, verify and validate the implementations.
It gets significantly more difficult to identify error sources, if the latter mentioned points are not taken seriously.
For example, a poor implementation design results in that the researcher waste valuable time to debug.
And, especially in a relative low-level programming language, such as C.

\subsection{Verification and Validation}
We developed a test case to verify the implementation' correctness.
That is, to test that the queues inserted the elements correctly.
We wrote a Python script that generates an input- and output-file.
The former consists of elements with random priorities, and the output file contains the elements in correct order.
Finally, we used these files in our implementations to verify its correctness.
We also used Valgrind to verify that we allocated and deallocated memory correctly.

\skippara
We developed tests for best, average and worst cases to validate its behavior.
That is, we analyzed the running time and complexity theoretically.
And, used statistical analysis to validate the algorithm with the theory, and vice versa.
Finally, we tried to use different inputs and examine different edge cases, for example, an empty or a list with only one element.

% Beskriv och motivera de experiment du designat (var noga att motivera varför de bidrar till att uppfylla målen)
\subsection{Experiments}
We developed a function that creates $n$ element with randomized priorities in the $[0,40]$ interval.
Furthermore, the verification use the latter mentioned distribution of elements as input to enqueue it in both the queue implementation based on the standard library and our implementation.
Finally, we dequeue the elements from the two queues to verify our implementation's correctness.

\skippara To test best, average and worst case, we created different priority distributions as input based on our complexity analysis of our algorithms.
This analysis takes place in \cref{sec:algorithms}.
The average case is more difficult to analyze theoretically.
However, we can assume that average case is between the best and worst case.
We randomly assigned priorities in $[0,40]$ interval to the elements in the average case tests.
Finally, \cref{tab:param} presents the remaining parameters we used for each test case.

\begin{table}
    \small
    \caption{Experiment parameters for each implementation and test case}
    \label{tab:param}
    \begin{adjustbox}{center}
        \renewcommand*\arraystretch{1.2}\begin{tabular}{| L{3.5cm} || L{5.5cm} |}
            \hline
            \textbf{Iterations} & 50
            \\ \hline
            \textbf{Elements} & 10 000 -- 60 000 (multiples of 5000)
            \\ \hline
        \end{tabular}
    \end{adjustbox}
\end{table}


\skippara The following list summarize the element's priority distribution, where $N$ is the set of elements, $p$ is a numerical priority and $n$ is the number of elements:
\clearpage
\begin{itemize}
    \item \textbf{Singly linked list}
        \begin{itemize}
            \item Best case -- Each element's priority increases linearly, for example,
                \begin{equation*}
                    N = \Big\{p_1, (p-1)_2, (p-2)_3, (p-3)_4,...,(p-n)_n \, \Big| \, p \ge n \ge 0 \Big\}
                \end{equation*}
            \item Worst case -- Each element's priority is the same, for example,
                \begin{equation*}
                    N = \Big\{p_{n} \, \Big| \, p \ge 0,\ n \ge 0 \Big\}
                \end{equation*}
        \end{itemize}
    \item \textbf{Doubly linked list}
        \begin{itemize}
            \item Best case -- Each element's priority is the same, for example,
                \begin{equation*}
                    N = \left\{p_{n} \, \Big| \, p \ge 0,\, n \ge 0 \right\}
                \end{equation*}
            \item Worst case -- Each element's priority increases linearly, for example,
                \begin{equation*}
                    N = \Big\{p_1, (p-1)_2, (p-2)_3, (p-3)_4,...,(p-n)_n \, \Big| \, p \ge n\ge 0 \Big\}
                \end{equation*}
        \end{itemize}
    \item \textbf{Doubly linked list with modification}
        \begin{itemize}
            \item Best case -- Each element's priority is the same, for example,
                \begin{equation*}
                    N = \left\{p_{n} \, \Big| \, p \ge 0,\, n \ge 0 \right\}
                \end{equation*}
            \item Worst case -- Insert two elements with significant different priority to skew the average.
                Then, linearly decrease the priority from one with the highest one, for example:
                \begin{equation*}
                    \resizebox{.9\hsize}{!}{$N = \left\{p_1, (p*2)_2, (p+1)_3, (p+2)_4, (p+3)_5,..., (p+n-2)_{(n-2)} \, \Big| \, p \ge n \ge 3 \right\}$}
                \end{equation*}
        \end{itemize}
    \item \textbf{Scheduling queue}
        \begin{itemize}
            \item Best case -- The element's priority is equally distributed, for example,
                \begin{equation*}
                    \resizebox{.9\hsize}{!}{$N = \left\{\left((p+1) \bmod 41\right)_1, \left((p+2) \bmod 41\right)_2,..., \left((p+n) \bmod 41\right)_n \, \Big| \, 0 \le p \le 40, \, n \ge 0\right\}$}
                \end{equation*}
            \item Worst case -- Each element's priority is the same, for example,
                \begin{equation*}
                    N = \left\{p_{n} \, \Big| \, p \ge 0,\, n \ge 0 \right\}
                \end{equation*}
        \end{itemize}
\end{itemize}

% ///////////////////////////////////
% ///////////////////////////////////
%              Results
% ///////////////////////////////////
% ///////////////////////////////////

% Här presenterar du dina resultat och slutsatser från undersökningen. Tänk på att presentera resultaten på ett tydligt sätt och ta med tillräckligt mycket i presentationen så att alla slutsatser är tydligt välgrundade. Lyft fram det som är mest intressant och viktigt.
\chapter{Results and Discussion}

\section{Running Time}
We visualized the running time results from the implementations with graphs and tables in \cref{app:singly}, \cref{app:doubly}, \cref{app:doublyavg} and \cref{app:arraypriority}.
That is, the singly linked list, doubly linked list, doubly linked list with modification and scheduling queue respectively.

\subsection{Enqueue}
The result's similarity is that the worst case tests represent an upper bound limit of time complexity for each of the algorithms.
The same goes for best case tests, that is, these show a lower bound limit.
And the average case's time complexity lies somewhere between these limits.
Another observation is that all the implementations perform similarly in best case and worst case.
Finally, the singly and doubly linked list yielded similar running time for the average case.
That is, around 18 seconds with 60 000 elements.

\skippara The doubly linked list with modification and scheduling queue algorithms produced a lower running time in average case tests.
That is, around 10 seconds and 1 second, respectively, for 60 000 elements.
The average case tests for the scheduling queue are only milliseconds higher than for its best case.
Whereas, the other implementation's average case tests produced running times that are several seconds higher than their average case.
That is, at least for more than 25 000 elements.



\subsection{Dequeue}

There is no significant changes in the results for these experiments, because the dequeue operation is similar for all the implementations.
That is, the elements are in the correct order in the queue.
The implementation only needs to dequeue and remove the element from the head of the list.
Thus, the running time slightly differ in milliseconds.

\section{Memory Usage}

\cref{app:memoryusage} summarizes the memory usage of all the implementations for best, average and worst case tests.
The memory is the same for each test on a specific implementation, because it allocates the same number of elements.
Thus, we did not have to calculate the mean and standard deviation value for memory usage.

\skippara All the implementations' memory usage increase linearly with the number of elements.
The doubly linked list with and without modification reached similar memory usage.
That is, around 4 Megabytes for 60 000 elements.
And, singly linked list and priority queue implementation had similar memory usage.
That is, around 6 Megabytes for 60 000 elements.
The singly linked list and queue implementation use significantly less memory than the variations of doubly linked list.
For example, for 60 000 elements, the former implementations use almost 2 Megabytes less memory than the queue based on doubly linked lists.

% Här kan du fördjupa din diskussion och ta ett helhetsgrepp på din undersökning, metodval och resultat.
\section{Discussion}
\subsection{Running Time Analysis}
Our complexity analysis matched with the results we generated from best, average and worst case tests.
That is, the worst case test represents an upper bound limit for the running time of the algorithms, and the best case the lower bound.
However, the most noticeable observation is that the scheduling queue implementation produced almost as low running time as for its lower bound limit.
Thus, the scheduling queue implementation performed the best in terms of time.

\skippara The scheduling queue has to traverse through a list, in general, fewer times than the rest of the implementations, because it has a assigned list for each priority.
We can use our complexity analysis and math notation to express the average running time, where $n$ represents number of elements:
\begin{itemize}
    \item \textbf{Singly Linked List and Doubly Linked List} -- In the worst case, these algorithms must traverse $n$ times.
        Thus, we assume in average that these algorithms must at most traverse $n/2$ times,
    \item \textbf{Doubly Linked List with Modification} -- It the worst case, this algorithm must traverses the list $n$ times.
        However, due to its modification, the insertion of new elements takes place in either the head or rear based on an average of first and last element's priority in the queue.
        Thus, we assume in average that this algorithm must at most traverse $n/4$ times.
    \item \textbf{Scheduling Priority} -- This algorithm traverses the list $n$ times in the worst case.
        However, due to its 41 different FIFO queues, each separate queues are in general shorter than the previous mentioned queues.
        Thus, we assume in average that this algorithm must at most traverse $n/41$ times.
\end{itemize}

\skippara Hence, based on the assumptions in the list above, we can summarize each implementation's average time complexity in relation to the number of elements as the following:
\begin{equation*}
    \begin{bmatrix*}
        \begin{array}{llll}
            (1) & \text{Singly Linked List} & = & \dfrac{n}{2} \\[3ex]
            (2) & \text{Doubly Linked List} & = & \dfrac{n}{2} \\[3ex]
            (3) & \text{Doubly Linked List with Modification} & = & \dfrac{n}{4} \\[3ex]
            (4) & \text{Scheduling Queue} & = & \dfrac{n}{41}
        \end{array}
    \end{bmatrix*}
    \implies \frac{n}{2} \ge \frac{n}{4} \ge \frac{n}{41}
\end{equation*}

\skippara In average, we noticed that time complexity of (4) is approximately $10\times$ higher than (3), and $20\times$ higher than (1) and (2).
Also, the time complexity of (1) and (2) is roughly $2\times$ higher than (1).
Thus, our running time results from the average case tests yielded similar time complexity.
For example, our running time for $n=60000$ was the following:
\begin{equation*}
    \begin{bmatrix*}
        \begin{array}{llllll}
            (1) & 17695.48 \pm 2\times 201.24 \text{ ms} & \approx 20000 \text{ ms}  & \approx 2\times(3)\text{ or } 20\times(4) \\[1ex]
            (2) & 18662.72 \pm 2\times 201.24 \text{ ms} & \approx 20000 \text{ ms}  & \approx 2\times(3)\text{ or } 20\times(4) \\[1ex]
            (3) & 9595.70 \pm 2\times 118.06 \text{ ms} & \approx 10000 \text{ ms} & \approx 10\times(4) \\[1ex]
            (4) & 950.29 \pm 2\times 22.56 \text{ ms} & \approx 1000 \text{ ms} &
        \end{array}
    \end{bmatrix*}
\end{equation*}

\skippara Finally, the dequeue operation for all the algorithms have similar behavior.
That is, all the dequeue operations take $\mathcal{O}(1)$ time.

\subsection{Memory Usage Analysis}
The reason both variations of doubly linked list has similar memory usage, and higher memory usage than singly linked list and scheduling queue, is because these implementations store in total two pointers.
That is, doubly linked lists have a pointer that connects to the previous element, and the second connects to the next element.
Singly linked list and scheduling queue only store one pointer, which refers to the next element in the queue.
Thus, the difference in memory usage is because of an extra pointer allocation.


% ///////////////////////////////////
% ///////////////////////////////////
%     Conclusions and Future Work
% ///////////////////////////////////
% ///////////////////////////////////

% Kan också kallas Diskussion eller Analys.
% Börja med att diskutera målen och syftet med undersökningen och hur väl du nått dem. Summera de viktigaste slutsatserna/upptäckterna och avsluta med att diskutera hur arbetet skulle kunna fortsättas/utvecklas (speciellt om du inte nått alla delmål)
\chapter{Conclusions and Future Work}

% I Bilagor (som inte alltid behöver finnas med) lägger man vid behov utökad information som man inte tar upp/redovisar i detalj i den ordinarie texten.
%
% För den här uppgiften är Bilagorna 1-3 sådana som man kan förvänta sig finnas med i en teknisk rapport om det specifika problem du studerat i den här uppgiften. Bilaga 4 skall innehålla de saker som efterfrågas i ID2206 för att rapporten skall kunna godkännas som labrapport i den kursen.
\appendix
\addappheadtotoc
% Bilaga 1: Källkod för algoritmerna
% Bilaga 2: Källkod för testerna (valideringen)
% Bilaga 3: Källkod för experimenten
% Bilaga 4: Rådata från testerna

\chapter{Requirement Overview}\label{app:A}
% ////////////////////////////////////////////////////////////////////////////////
% ////////////////////////////////////////////////////////////////////////////////
% ////////////////////////////////////////////////////////////////////////////////
% ////////////////////////////////////////////////////////////////////////////////
% //////////////////// CHANGE THIS!!! ////////////////////////////////////////////
% ////////////////////////////////////////////////////////////////////////////////
% ////////////////////////////////////////////////////////////////////////////////
% ////////////////////////////////////////////////////////////////////////////////
% ////////////////////////////////////////////////////////////////////////////////

In \cite{web:requirementoverview}, the author describes that a requirement analysis is a summary of all the requirement the researcher can find.
The author clearly states that this document is \emph{not} about how one should implement something to achieve a specific requirement.
On the contrary, it should only cover the meaning of the requirement.
Thus, we need to set up requirements that describes how to pass the task about the scientific method, specifically experimental quantitative method, as shown in \cref{tab:requirement}.

{\footnotesize
    \begin{longtable}{ |P{2cm}||P{1.7cm}|P{2.2cm}|P{4.3cm}|P{2.3cm}| }
        \caption{Requirement analysis about the scientific method} \label{tab:requirement}\\
        \hline
        Requirement number & Requirement type & Name or source & Clarified description of the requirement, followed by what should be fulfilled& Fulfilled or not fulfilled or partly fulfilled\\
        \hline
        1 & \textbf{Must} mandatory task & Purpose \cite{A3Experi4:online} & Ask good questions and identify the purpose. That is, why is it necessary to conduct an experimental evaluation of algorithms, and what is the application of it. The specific task description is described in \cite{Uppgiftl9:online}. & \\
        \hline
        2 & \textbf{Must} mandatory task & Prestudy \cite{A3Experi4:online} & Demonstrate an understanding about the task and field of study. Also, identify which parameters to use, how these can depend on and vary from each other & \\
        \hline
        3 & \textbf{Must} mandatory task & Methods \cite{A3Experi4:online} & Identify which scientific method(s) to use. For example, quantitative, qualitative, deductive and/or inductive method & \\
        \hline
        4 & \textbf{Must} mandatory task & Experimental Plan \cite{A3Experi4:online} & Identify experiments to conduct. Describe why these are relevant. Examine metrics to measure and elaborate on why these are relevant to this study. & \\
        \hline
        5 & \textbf{Must} mandatory task & Experimental Setup \cite{A3Experi4:online} & Describe in details the resources needed. Identify and examine the influence of error sources, both external and internal ones. Set up an implementation, verification and validation plan. & \\
        \hline
        5 & \textbf{Must} mandatory task & Goals \cite{A3Experi4:online} & Demonstrate how to determine when a goal is reached and an experiment is completed. & \\
        \hline
        6 & \textbf{Must} mandatory task & Communication Part \RN{1} \cite{A3Experi4:online} & Communicate and summarize the discussions of requirement 1-5 (\cref{app:A}) in a document and hand it in to the mentor/supervisor & \\
        \hline
        7 & \textbf{Must} mandatory task & Experimental Execution \cite{A3Experi4:online, Uppgiftl9:online} & Follow the discussed requirements 1-5, or only 6, to conduct the experiments on a real system. And, regularly document the findings with honesty and transparency. & \\
        \hline
        8 & \textbf{Must} mandatory task & Communication Part \RN{2} \cite{A3Experi7:online} & Summarize the entire work and its requirements, that is 1-7, in a smaller version of a technical report. Use the IMRAD-structure (Introduction, Method, Results, and Discussion). It is a common communication structure in scientific reports. & \\
        \hline
\end{longtable}}

% \begin{figure}[ht]
%     \begin{center}
%         And here is a figure
%         \caption{\small{Several statements describing the same resource.}}\label{RDF_4}
%     \end{center}
% \end{figure}

% that we refer to here: \ref{RDF_4}

\chapter{Results -- Singly Linked List}\label{app:singly}

\begin{figure}[h!]
    \begin{adjustbox}{width=1\textwidth, center}
        \renewcommand*\arraystretch{1.5}
        \begin{tikzpicture}
            \begin{axis}[
                title={},
                legend style={font=\scriptsize},
                x label style = {text height = 0.7cm},
                xlabel={Number of elements},
                ylabel={Seconds},
                xmin=10000, xmax=60000,
                ymin=0, ymax=42,
                xtick={10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 55000, 60000},
                ytick={0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42},
                legend pos=south east,
                ymajorgrids=true,
                grid style=dashed,
                height=11cm,
                width=20cm,
                /pgf/number format/.cd,
                1000 sep={}
                ]

                \addplot [style=thick, color=green, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../results/singly_linked_list_best_enqueue.dat};

                \addplot [style=thick, color=blue, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../results/singly_linked_list_avg_enqueue.dat};

                \addplot [style=thick, color=red, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../results/singly_linked_list_worst_enqueue.dat};

                \legend{Best, Average, Worst}

            \end{axis}
        \end{tikzpicture}
    \end{adjustbox}
    \caption{Running Time Enqueue Results -- Singly Linked List}
    \label{graph:Esingly}
\end{figure}

\begin{table}[ht!]
\caption{Best Case Enqueue -- Singly Linked List }
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000*2},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/singly_linked_list_best_enqueue.dat}
\end{table}

\begin{table}[ht!]
\caption{Average Case Enqueue -- Singly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/singly_linked_list_avg_enqueue.dat}
\end{table}

\begin{table}[ht!]
\caption{Worst Case Enqueue -- Singly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/singly_linked_list_worst_enqueue.dat}
\end{table}

\begin{figure}[h!]
    \begin{adjustbox}{width=1\textwidth, center}
        \renewcommand*\arraystretch{1.5}
        \begin{tikzpicture}
            \begin{axis}[
                title={},
                legend style={font=\scriptsize},
                x label style = {text height = 0.7cm},
                xlabel={Number of elements},
                ylabel={Milliseconds},
                xmin=10000, xmax=60000,
                ymin=0, ymax=20,
                xtick={10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 55000, 60000},
                ytick={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20},
                legend pos=south east,
                ymajorgrids=true,
                grid style=dashed,
                height=11cm,
                width=20cm,
                /pgf/number format/.cd,
                1000 sep={}
                ]

                \addplot [style=thick, color=green, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../results/singly_linked_list_best_dequeue.dat};

                \addplot [style=thick, color=blue, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../results/singly_linked_list_avg_dequeue.dat};

                \addplot [style=thick, color=red, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../results/singly_linked_list_worst_dequeue.dat};


                \legend{Best, Average, Worst}

            \end{axis}
        \end{tikzpicture}
    \end{adjustbox}
    \caption{Running Time Dequeue Results -- Singly Linked List}
    \label{}
\end{figure}

\clearpage

\begin{table}[ht!]
\caption{Best Case Dequeue -- Singly Linked List }
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/singly_linked_list_best_dequeue.dat}
\end{table}

\begin{table}[ht!]
\caption{Average Case Dequeue -- Singly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/singly_linked_list_avg_dequeue.dat}
\end{table}

\begin{table}[ht!]
\caption{Worst Case Dequeue -- Singly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/singly_linked_list_worst_dequeue.dat}
\end{table}



\chapter{Results -- Doubly Linked List}\label{app:doubly}

\begin{figure}[h!]
    \begin{adjustbox}{width=1\textwidth, center}
        \renewcommand*\arraystretch{1.5}
        \begin{tikzpicture}
            \begin{axis}[
                title={},
                legend style={font=\scriptsize},
                x label style = {text height = 0.7cm},
                xlabel={Number of elements},
                ylabel={Seconds},
                xmin=10000, xmax=60000,
                ymin=0, ymax=42,
                xtick={10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 55000, 60000},
                ytick={0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42},
                legend pos=south east,
                ymajorgrids=true,
                grid style=dashed,
                height=11cm,
                width=20cm,
                /pgf/number format/.cd,
                1000 sep={}
                ]

                \addplot [style=thick, color=green, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../results/doubly_linked_list_best_enqueue.dat};

                \addplot [style=thick, color=blue, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../results/doubly_linked_list_avg_enqueue.dat};

                \addplot [style=thick, color=red, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../results/doubly_linked_list_worst_enqueue.dat};

                \legend{Best, Average, Worst}

            \end{axis}
        \end{tikzpicture}
    \end{adjustbox}
    \caption{Running Time Enqueue Results -- Doubly Linked List}
    \label{graph:Edoubly}
\end{figure}

\begin{table}[ht!]
\caption{Best Case Enqueue -- Doubly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/doubly_linked_list_best_enqueue.dat}
\end{table}

\begin{table}[ht!]
\caption{Average Case Enqueue -- Doubly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/doubly_linked_list_avg_enqueue.dat}
\end{table}

\begin{table}[ht!]
\caption{Worst Case Enqueue -- Doubly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    1000 sep={},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/doubly_linked_list_worst_enqueue.dat}
\end{table}

\begin{figure}[h!]
    \begin{adjustbox}{width=1\textwidth, center}
        \renewcommand*\arraystretch{1.5}
        \begin{tikzpicture}
            \begin{axis}[
                title={},
                legend style={font=\scriptsize},
                x label style = {text height = 0.7cm},
                xlabel={Number of elements},
                ylabel={Milliseconds},
                xmin=10000, xmax=60000,
                ymin=0, ymax=20,
                xtick={10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 55000, 60000},
                ytick={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20},
                legend pos=south east,
                ymajorgrids=true,
                grid style=dashed,
                height=11cm,
                width=20cm,
                /pgf/number format/.cd,
                1000 sep={}
                ]

                \addplot [style=thick, color=green, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../results/doubly_linked_list_best_dequeue.dat};

                \addplot [style=thick, color=blue, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../results/doubly_linked_list_avg_dequeue.dat};

                \addplot [style=thick, color=red, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../results/doubly_linked_list_worst_dequeue.dat};


                \legend{Best, Average, Worst}

            \end{axis}
        \end{tikzpicture}
    \end{adjustbox}
    \caption{Running Time Dequeue Results -- Doubly Linked List}
    \label{}
\end{figure}
\clearpage

\begin{table}[ht!]
\caption{Best Case Dequeue -- Doubly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/doubly_linked_list_best_dequeue.dat}
\end{table}

\begin{table}[ht!]
\caption{Average Case Dequeue -- Doubly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/doubly_linked_list_avg_dequeue.dat}
\end{table}

\begin{table}[ht!]
\caption{Worst Case Dequeue -- Doubly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/doubly_linked_list_worst_dequeue.dat}
\end{table}

\chapter{Results -- Doubly Linked List with Modification}\label{app:doublyavg}

\begin{figure}[h!]
    \begin{adjustbox}{width=1\textwidth, center}
        \renewcommand*\arraystretch{1.5}
        \begin{tikzpicture}
            \begin{axis}[
                title={},
                legend style={font=\scriptsize},
                x label style = {text height = 0.7cm},
                xlabel={Number of elements},
                ylabel={Seconds},
                xmin=10000, xmax=60000,
                ymin=0, ymax=42,
                xtick={10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 55000, 60000},
                ytick={0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42},
                legend pos=south east,
                ymajorgrids=true,
                grid style=dashed,
                height=11cm,
                width=20cm,
                /pgf/number format/.cd,
                1000 sep={}
                ]

                \addplot [style=thick, color=green, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../results/doubly_linked_list_avg_best_enqueue.dat};

                \addplot [style=thick, color=blue, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../results/doubly_linked_list_avg_avg_enqueue.dat};

                \addplot [style=thick, color=red, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../results/doubly_linked_list_avg_worst_enqueue.dat};

                \legend{Best, Average, Worst}

            \end{axis}
        \end{tikzpicture}
    \end{adjustbox}
    \caption{Running Time Enqueue Results -- Doubly Linked List with Modification}
    \label{graph:Eavg}
\end{figure}

\begin{table}[ht!]
\caption{Best Case Enqueue -- Doubly Linked List with Modification}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/doubly_linked_list_avg_best_enqueue.dat}
\end{table}


\begin{table}[ht!]
\caption{Average Case Enqueue -- Doubly Linked List with Modification}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/doubly_linked_list_avg_avg_enqueue.dat}
\end{table}

\begin{table}[ht!]
\caption{Worst Case Enqueue -- Doubly Linked List with Modification}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    1000 sep={},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/doubly_linked_list_avg_worst_enqueue.dat}
\end{table}

\begin{figure}[h!]
    \begin{adjustbox}{width=1\textwidth, center}
        \renewcommand*\arraystretch{1.5}
        \begin{tikzpicture}
            \begin{axis}[
                title={},
                legend style={font=\scriptsize},
                x label style = {text height = 0.7cm},
                xlabel={Number of elements},
                ylabel={Milliseconds},
                xmin=10000, xmax=60000,
                ymin=0, ymax=20,
                xtick={10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 55000, 60000},
                ytick={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20},
                legend pos=south east,
                ymajorgrids=true,
                grid style=dashed,
                height=11cm,
                width=20cm,
                /pgf/number format/.cd,
                1000 sep={}
                ]

                \addplot [style=thick, color=green, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000,y expr = \thisrowno{1}*1000]{../results/doubly_linked_list_avg_best_dequeue.dat};

                \addplot [style=thick, color=blue, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../results/doubly_linked_list_avg_avg_dequeue.dat};

                \addplot [style=thick, color=red, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../results/doubly_linked_list_avg_worst_dequeue.dat};


                \legend{Best, Average, Worst}

            \end{axis}
        \end{tikzpicture}
    \end{adjustbox}
    \caption{Running Time Dequeue Results -- Doubly Linked List with Modification}
    \label{}
\end{figure}
\clearpage


\begin{table}[ht!]
\caption{Best Case Dequeue -- Doubly Linked List with Modification}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/doubly_linked_list_avg_best_dequeue.dat}
\end{table}

\begin{table}[ht!]
\caption{Average Case Dequeue -- Doubly Linked List with Modification}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/doubly_linked_list_avg_avg_dequeue.dat}
\end{table}

\begin{table}[ht!]
\caption{Worst Case Dequeue -- Doubly Linked List with Modification}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/doubly_linked_list_avg_worst_dequeue.dat}
\end{table}

\chapter{Results -- Scheduling Queue}\label{app:arraypriority}

\begin{figure}[h!]
    \begin{adjustbox}{width=1\textwidth, center}
        \renewcommand*\arraystretch{1.5}
        \begin{tikzpicture}
            \begin{axis}[
                title={},
                legend style={font=\scriptsize},
                x label style = {text height = 0.7cm},
                xlabel={Number of elements},
                ylabel={Seconds},
                xmin=10000, xmax=60000,
                ymin=0, ymax=42,
                xtick={10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 55000, 60000},
                ytick={0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42},
                legend pos=south east,
                ymajorgrids=true,
                grid style=dashed,
                height=11cm,
                width=20cm,
                /pgf/number format/.cd,
                1000 sep={}
                ]

                \addplot [style=thick, color=green, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../results/array_priority_best_enqueue.dat};

                \addplot [style=thick, color=blue, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../results/array_priority_avg_enqueue.dat};

                \addplot [style=thick, color=red, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2]{../results/array_priority_worst_enqueue.dat};


                \legend{Best, Average, Worst}

            \end{axis}
        \end{tikzpicture}
    \end{adjustbox}
    \caption{Running Time Enqueue Results -- Scheduling Queue}
    \label{graph:Earray}
\end{figure}
\begin{table}[ht!]
\caption{Best Case Enqueue -- Scheduling Queue}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/array_priority_best_enqueue.dat}
\end{table}




\begin{table}[ht!]
\caption{Average Case Enqueue -- Scheduling Queue}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/array_priority_avg_enqueue.dat}
\end{table}




\begin{table}[ht!]
\caption{Worst Case Enqueue -- Scheduling Queue}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/array_priority_worst_enqueue.dat}
\end{table}


\begin{figure}[h!]
    \begin{adjustbox}{width=1\textwidth, center}
        \renewcommand*\arraystretch{1.5}
        \begin{tikzpicture}
            \begin{axis}[
                title={},
                legend style={font=\scriptsize},
                x label style = {text height = 0.7cm},
                xlabel={Number of elements},
                ylabel={Milliseconds},
                xmin=10000, xmax=60000,
                ymin=0, ymax=20,
                xtick={10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 55000, 60000},
                ytick={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20},
                legend pos=south east,
                ymajorgrids=true,
                grid style=dashed,
                height=11cm,
                width=20cm,
                /pgf/number format/.cd,
                1000 sep={}
                ]

                \addplot [style=thick, color=green, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../results/array_priority_best_dequeue.dat};

                \addplot [style=thick, color=blue, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../results/array_priority_avg_dequeue.dat};

                \addplot [style=thick, color=red, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[y error index=2, y error expr = \thisrowno{2}*2*1000, y expr = \thisrowno{1}*1000]{../results/array_priority_worst_dequeue.dat};


                \legend{Best, Average, Worst}

            \end{axis}
        \end{tikzpicture}
    \end{adjustbox}
    \caption{Running Time Dequeue Results -- Scheduling Queue}
    \label{}
\end{figure}

\clearpage

\begin{table}[ht!]
\caption{Best Case Dequeue -- Scheduling Queue}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/array_priority_best_dequeue.dat}
\end{table}




\begin{table}[ht!]
\caption{Average Case Dequeue -- Scheduling Queue}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/array_priority_avg_dequeue.dat}
\end{table}




\begin{table}[ht!]
\caption{Worst Case Dequeue -- Scheduling Queue}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Running Time in Milliseconds},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*1000},
    1000 sep={},
    /pgf/number format/precision=2,
},
columns/2/.style={
    column name={$2\times$SD ($N=50$)},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1*2*1000},
    /pgf/number format/precision=2
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/array_priority_worst_dequeue.dat}
\end{table}

\chapter{Results -- Memory Usage}\label{app:memoryusage}

The best, worst, average case tests are included in the total memory usage for each implementation.
Thus, the higher memory usage.

\begin{figure}[h!]
    \begin{adjustbox}{width=1\textwidth, center}
        \renewcommand*\arraystretch{1.5}
        \begin{tikzpicture}
            \begin{axis}[
                title={},
                legend style={font=\scriptsize},
                x label style = {text height = 0.7cm},
                xlabel={Number of elements},
                ylabel={Bytes},
                xmin=10000, xmax=60000,
                ymin=0, ymax=6000000,
                xtick={10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 55000, 60000},
                ytick={0, 500000, 1000000, 1500000, 2000000, 2500000, 3000000, 3500000, 4000000, 4500000, 5000000, 5500000, 6000000},
                legend pos=south east,
                ymajorgrids=true,
                grid style=dashed,
                height=11cm,
                width=20cm,
                /pgf/number format/.cd,
                1000 sep={}
                ]

                \addplot [style=thick, color=green, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[]{../results/singly_linked_list_memory.dat};

                \addplot [style=thick, color=blue, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[]{../results/doubly_linked_list_memory.dat};

                \addplot [color=red, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[]{../results/doubly_linked_list_avg_memory.dat};

                \addplot [color=black, mark=o]
                plot [error bars/.cd, y dir = both, y explicit]
                table[]{../results/array_priority_memory.dat};

                \legend{Singly Linked List, Doubly Linked List, Doubly Linked List with modification, Scheduling Queue}

            \end{axis}
        \end{tikzpicture}
    \end{adjustbox}
    \caption{Memory Usage Results of the All Queues}
    \label{graph:memoryusage}
\end{figure}

\begin{table}[ht!]
\caption{Memory Usage -- Singly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Memory Usage in Megabytes},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1/1000000},
    1000 sep={},
    /pgf/number format/precision=2,
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/singly_linked_list_memory.dat}
\end{table}

\begin{table}[ht!]
\caption{Memory Usage -- Doubly Linked List}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Memory Usage in Megabytes},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1/1000000},
    1000 sep={},
    /pgf/number format/precision=2,
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/doubly_linked_list_memory.dat}
\end{table}

\begin{table}[ht!]
\caption{Memory Usage -- Doubly Linked List with Modification}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Memory Usage in Megabytes},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1/1000000},
    1000 sep={},
    /pgf/number format/precision=2,
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/doubly_linked_list_avg_memory.dat}
\end{table}

\begin{table}[ht!]
\caption{Memory Usage -- Scheduling Queue}
\centering
\label{}
\small
\pgfplotstabletypeset[
columns/0/.style={
    column name={Number of Elements},
    /pgf/number format/.cd,
    1000 sep={}
},
columns/1/.style={
    column name={Memory Usage in Megabytes},
    /pgf/number format/fixed zerofill,
    /pgfplots/table/preproc/expr={##1/1000000},
    1000 sep={},
    /pgf/number format/precision=2,
},
every head row/.style={
    before row=\toprule,
    after row=\midrule
},
every last row/.style={
    after row=\bottomrule
},
every odd row/.style={
    before row={\rowcolor[gray]{.8}}
}
]{../results/array_priority_memory.dat}
\end{table}

\clearpage
% Här listar du dina referenser. De skall täcka in alla relevanta delar  i din bakgrund, vara väl utvalda (dvs. hålla för källkritik).
%
% I den här rapporten använder du ISO690 numerisk variant för referenserna.
%
% Har man ett bra verktyg som man skriver i/hantera referenserna i så kan referenslistan automatgenereras. Det gör det också lättare att uppdatera referenslistan utan att behöva gå igenom varje referens i texten manuellt. Dessutom får man bara med källor som man refererat till minst en gång från texten.
\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,sources}
\end{document}
